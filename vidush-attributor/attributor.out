[Attributor] Run on module with 3 functions:
  - foo
  - printf
  - main
[Attributor] Update: [AAIsDead] for CtxI '  %f = alloca %struct.Foo, align 4' at position {fn:foo [foo@-1]} with state Live[#BB 1/1][#TBEP 1][#KDE 0]

[AAIsDead] Live [1/1] BBs and 1 exploration points and 0 known dead ends
[AAIsDead] Exploration inst:   %f = alloca %struct.Foo, align 4
[AAIsDead] #AliveSuccessors: 1 UsedAssumedInformation: 0
[AAIsDead] Exploration inst:   ret void
[AAIsDead] #AliveSuccessors: 0 UsedAssumedInformation: 0
[Attributor] Update changed [AAIsDead] for CtxI '  %f = alloca %struct.Foo, align 4' at position {fn:foo [foo@-1]} with state Live[#BB 1/1][#TBEP 0][#KDE 1]

[Attributor] Update: [AAUndefinedBehavior] for CtxI '  %f = alloca %struct.Foo, align 4' at position {fn:foo [foo@-1]} with state undefined-behavior

[Attributor] Update: [AAPotentialValues] for CtxI '  %a1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:a1 [a1@-1]} with state set-state(< {} >)

The instruction encountered was:   %f = alloca %struct.Foo, align 4!
The instruction Opcode was: 31!
[Attributor] Update: [AAPotentialValues] for CtxI '  %f = alloca %struct.Foo, align 4' at position {flt:f [f@-1]} with state set-state(< {} >)

The instruction encountered was:   %f = alloca %struct.Foo, align 4!
The instruction Opcode was: 31!
[Attributor] Update changed [AAPotentialValues] for CtxI '  %f = alloca %struct.Foo, align 4' at position {flt:f [f@-1]} with state set-state(< {  %f = alloca %struct.Foo, align 4[3], } >)

[Attributor] Update changed [AAPotentialValues] for CtxI '  %a1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:a1 [a1@-1]} with state set-state(< {  %f = alloca %struct.Foo, align 4[3], } >)

[Attributor] Update: [AAPotentialValues] for CtxI '  %a1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:a1 [a1@-1]} with state set-state(< {  %f = alloca %struct.Foo, align 4[3], } >)

The instruction encountered was:   %f = alloca %struct.Foo, align 4!
The instruction Opcode was: 31!
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %a1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:a1 [a1@-1]} with state set-state(< {  %f = alloca %struct.Foo, align 4[3], } >)

[Attributor] Update: [AAPotentialValues] for CtxI '  %a = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:a [a@-1]} with state set-state(< {} >)

The instruction encountered was:   %f = alloca %struct.Foo, align 4!
The instruction Opcode was: 31!
[Attributor] Update changed [AAPotentialValues] for CtxI '  %a = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:a [a@-1]} with state set-state(< {  %f = alloca %struct.Foo, align 4[3], } >)

[Attributor] Update: [AAPotentialValues] for CtxI '  %a = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:a [a@-1]} with state set-state(< {  %f = alloca %struct.Foo, align 4[3], } >)

The instruction encountered was:   %f = alloca %struct.Foo, align 4!
The instruction Opcode was: 31!
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %a = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:a [a@-1]} with state set-state(< {  %f = alloca %struct.Foo, align 4[3], } >)

[Attributor] Update: [AANoUnwind] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %0)' at position {cs:call [call@-1]} with state nounwind

[Attributor] Update changed [AANoUnwind] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %0)' at position {cs:call [call@-1]} with state may-unwind

[Attributor] Update changed [AAUndefinedBehavior] for CtxI '  %f = alloca %struct.Foo, align 4' at position {fn:foo [foo@-1]} with state undefined-behavior

[Attributor] Update: [AAUndefinedBehavior] for CtxI '  %f = alloca %struct.Foo, align 4' at position {fn:foo [foo@-1]} with state undefined-behavior

[Attributor] Update unchanged [AAUndefinedBehavior] for CtxI '  %f = alloca %struct.Foo, align 4' at position {fn:foo [foo@-1]} with state undefined-behavior

[Attributor] Update: [AAHeapToStack] for CtxI '  %f = alloca %struct.Foo, align 4' at position {fn:foo [foo@-1]} with state [H2S] Mallocs Good/Bad: 0/0

[Attributor] Update unchanged [AAHeapToStack] for CtxI '  %f = alloca %struct.Foo, align 4' at position {fn:foo [foo@-1]} with state [H2S] Mallocs Good/Bad: 0/0

[Attributor] Update: [AAWillReturn] for CtxI '  %f = alloca %struct.Foo, align 4' at position {fn:foo [foo@-1]} with state willreturn

[Attributor] Update: [AAWillReturn] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %0)' at position {cs:call [call@-1]} with state willreturn

[Attributor] Update changed [AAWillReturn] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %0)' at position {cs:call [call@-1]} with state may-noreturn

[Attributor] Update changed [AAWillReturn] for CtxI '  %f = alloca %struct.Foo, align 4' at position {fn:foo [foo@-1]} with state may-noreturn

[Attributor] Update: [AAMustProgress] for CtxI '  %f = alloca %struct.Foo, align 4' at position {fn:foo [foo@-1]} with state mustprogress

[Attributor] Function foo has no internal linkage, hence not all call sites are known
[Attributor] Update changed [AAMustProgress] for CtxI '  %f = alloca %struct.Foo, align 4' at position {fn:foo [foo@-1]} with state may-not-progress

[Attributor] Update: [AANoSync] for CtxI '  %f = alloca %struct.Foo, align 4' at position {fn:foo [foo@-1]} with state nosync

[Attributor] Update: [AAIsDead] for CtxI '  store i32 10, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead-store

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 10, ptr %a, align 4 (only exact: 0)
[Attributor] Update: [AAUnderlyingObjects] for CtxI '  %a = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:a [a@-1]} with state UnderlyingObjects inter #0 objs, intra #0 objs

[Attributor] Update changed [AAUnderlyingObjects] for CtxI '  %a = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:a [a@-1]} with state UnderlyingObjects inter #1 objs, intra #1 objs

[Attributor] Update: [AAUnderlyingObjects] for CtxI '  %a = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:a [a@-1]} with state UnderlyingObjects inter #1 objs, intra #1 objs

[Attributor] Update unchanged [AAUnderlyingObjects] for CtxI '  %a = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:a [a@-1]} with state UnderlyingObjects inter #1 objs, intra #1 objs

Visit underlying object   %f = alloca %struct.Foo, align 4
Reached here!
[Attributor] Update: [AAPointerInfo] for CtxI '  %f = alloca %struct.Foo, align 4' at position {flt:f [f@-1]} with state PointerInfo #0 bins

[Attributor] Got 2 initial uses to check
[AAPointerInfo] Analyze   %f = alloca %struct.Foo, align 4 in   %a = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] GEP offset is  constant   %a = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] Analyze   %a = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   store i32 10, ptr %a, align 4
[AAPointerInfo] Inserting access in new offset bins
    key [0, 4]
[AAPointerInfo] Analyze   %f = alloca %struct.Foo, align 4 in   %a1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] GEP offset is  constant   %a1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] Analyze   %a1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   %0 = load i32, ptr %a1, align 4
[AAPointerInfo] Inserting access in new offset bins
    key [0, 4]
Accesses by bin after update:
[0-4] : 2
     - 9 -   store i32 10, ptr %a, align 4
       - c: i32 10
     - 5 -   %0 = load i32, ptr %a1, align 4
       - c: <unknown>
[Attributor] Update changed [AAPointerInfo] for CtxI '  %f = alloca %struct.Foo, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

[Attributor] Update: [AAPointerInfo] for CtxI '  %f = alloca %struct.Foo, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

[Attributor] Got 2 initial uses to check
[AAPointerInfo] Analyze   %f = alloca %struct.Foo, align 4 in   %a = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] GEP offset is  constant   %a = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] Analyze   %a = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   store i32 10, ptr %a, align 4
[AAPointerInfo] Analyze   %f = alloca %struct.Foo, align 4 in   %a1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] GEP offset is  constant   %a1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] Analyze   %a1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   %0 = load i32, ptr %a1, align 4
Accesses by bin after update:
[0-4] : 2
     - 9 -   store i32 10, ptr %a, align 4
       - c: i32 10
     - 5 -   %0 = load i32, ptr %a1, align 4
       - c: <unknown>
[Attributor] Update unchanged [AAPointerInfo] for CtxI '  %f = alloca %struct.Foo, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

[Attributor] Update: [AANoCapture] for CtxI '  %f = alloca %struct.Foo, align 4' at position {flt:f [f@-1]} with state assumed not-captured

[Attributor] Update: [AAMemoryBehavior] for CtxI '  %f = alloca %struct.Foo, align 4' at position {fn:foo [foo@-1]} with state readnone

[Attributor] Update: [AAIsDead] for CtxI '  %0 = load i32, ptr %a1, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Update: [AAPotentialValues] for CtxI '  %0 = load i32, ptr %a1, align 4' at position {flt: [@-1]} with state set-state(< {} >)

The instruction encountered was:   %0 = load i32, ptr %a1, align 4!
The instruction Opcode was: 32!
getPotentiallyLoadedValues!
Trying to determine the potential copies of   %0 = load i32, ptr %a1, align 4 (only exact: 1)
[Attributor] Update: [AAUnderlyingObjects] for CtxI '  %a1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:a1 [a1@-1]} with state UnderlyingObjects inter #0 objs, intra #0 objs

[Attributor] Update changed [AAUnderlyingObjects] for CtxI '  %a1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:a1 [a1@-1]} with state UnderlyingObjects inter #1 objs, intra #1 objs

[Attributor] Update: [AAUnderlyingObjects] for CtxI '  %a1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:a1 [a1@-1]} with state UnderlyingObjects inter #1 objs, intra #1 objs

[Attributor] Update unchanged [AAUnderlyingObjects] for CtxI '  %a1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:a1 [a1@-1]} with state UnderlyingObjects inter #1 objs, intra #1 objs

Visit underlying object   %f = alloca %struct.Foo, align 4
Reached here!
[AA] Object '  %f = alloca %struct.Foo, align 4' is  thread local; non-captured stack object.
[Attributor] Update: [AANoRecurse] for CtxI '  %f = alloca %struct.Foo, align 4' at position {fn:foo [foo@-1]} with state norecurse

[Attributor] Function foo has no internal linkage, hence not all call sites are known
[Attributor] Update: [AAInterFnReachability] for CtxI '  %f = alloca %struct.Foo, align 4' at position {fn:foo [foo@-1]} with state #queries(0)

[Attributor] Update unchanged [AAInterFnReachability] for CtxI '  %f = alloca %struct.Foo, align 4' at position {fn:foo [foo@-1]} with state #queries(0)

[Attributor] Update: [AAIntraFnReachability] for CtxI '  %f = alloca %struct.Foo, align 4' at position {fn:foo [foo@-1]} with state #queries(0)

[Attributor] Update unchanged [AAIntraFnReachability] for CtxI '  %f = alloca %struct.Foo, align 4' at position {fn:foo [foo@-1]} with state #queries(0)

[Attributor] Update: [AACallEdges] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %0)' at position {cs:call [call@-1]} with state CallEdges[0,0]

[AACallEdges] New call edge: printf
[Attributor] Update changed [AACallEdges] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %0)' at position {cs:call [call@-1]} with state CallEdges[0,1]

[Attributor] Update: [AACallEdges] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %0)' at position {cs:call [call@-1]} with state CallEdges[0,1]

[Attributor] Update unchanged [AACallEdges] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %0)' at position {cs:call [call@-1]} with state CallEdges[0,1]

[Attributor] Update changed [AANoRecurse] for CtxI '  %f = alloca %struct.Foo, align 4' at position {fn:foo [foo@-1]} with state may-recurse

[AA] check   %0 = load i32, ptr %a1, align 4 from   store i32 10, ptr %a, align 4 intraprocedurally
[AA]   store i32 10, ptr %a, align 4 can potentially reach   %0 = load i32, ptr %a1, align 4 [Intra]
[Attributor] Update changed [AAPotentialValues] for CtxI '  %0 = load i32, ptr %a1, align 4' at position {flt: [@-1]} with state set-state(< {i32 10[3], } >)

[Attributor] Update unchanged [AAIsDead] for CtxI '  %0 = load i32, ptr %a1, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Update: [AAMemoryBehavior] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %0)' at position {cs:call [call@-1]} with state readnone

[Attributor] Update changed [AAMemoryBehavior] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %0)' at position {cs:call [call@-1]} with state may-read/write

[Attributor] Update changed [AAMemoryBehavior] for CtxI '  %f = alloca %struct.Foo, align 4' at position {fn:foo [foo@-1]} with state may-read/write

[Attributor] Update: [AAMemoryLocation] for CtxI '  %f = alloca %struct.Foo, align 4' at position {fn:foo [foo@-1]} with state memory

[AAMemoryLocation] Categorize accessed locations for   store i32 10, ptr %a, align 4
[AAMemoryLocation] Categorize memory access with pointer:   store i32 10, ptr %a, align 4 [  %a = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0]
[AAMemoryLocation] Categorize pointer locations for   %a = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 [no memory]
[AAMemoryLocation] Ptr value can be categorized:   %f = alloca %struct.Foo, align 4 -> memory:constant,internal global,external global,argument,inaccessible,malloced,unknown
[AAMemoryLocation] Accessed locations with pointer locations: memory:stack
[AAMemoryLocation] Accessed locations for   store i32 10, ptr %a, align 4: memory:stack
[AAMemoryLocation] Categorize accessed locations for   %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %0)
[Attributor] Update: [AAMemoryLocation] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %0)' at position {cs:call [call@-1]} with state memory

[Attributor] Update changed [AAMemoryLocation] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %0)' at position {cs:call [call@-1]} with state all memory

[AAMemoryLocation] Categorize call site:   %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %0) [0x55df3287cae0]
[AAMemoryLocation] Accessed locations for   %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %0): all memory
[Attributor] Update changed [AAMemoryLocation] for CtxI '  %f = alloca %struct.Foo, align 4' at position {fn:foo [foo@-1]} with state all memory

[Attributor] Got 2 initial uses to check
[Attributor] Update: [AAIsDead] for CtxI '  %a = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:a [a@-1]} with state assumed-dead

[Attributor] Got 1 initial uses to check
[Attributor] Update changed [AAIsDead] for CtxI '  %a = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:a [a@-1]} with state assumed-live

[Attributor] Update: [AAIsDead] for CtxI '  %a1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:a1 [a1@-1]} with state assumed-dead

[Attributor] Got 1 initial uses to check
[Attributor] Update unchanged [AAIsDead] for CtxI '  %a1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:a1 [a1@-1]} with state assumed-dead

[Attributor] Update unchanged [AANoCapture] for CtxI '  %f = alloca %struct.Foo, align 4' at position {flt:f [f@-1]} with state assumed not-captured

[AA] Object '  %f = alloca %struct.Foo, align 4' is  thread local; non-captured stack object.
[AA] check   %0 = load i32, ptr %a1, align 4 from   store i32 10, ptr %a, align 4 intraprocedurally
[AA]   store i32 10, ptr %a, align 4 can potentially reach   %0 = load i32, ptr %a1, align 4 [Intra]
[AAIsDead] Store has 1 potential copies.
[Attributor] Update unchanged [AAIsDead] for CtxI '  store i32 10, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead-store

[Attributor] Update: [AANoSync] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %0)' at position {cs:call [call@-1]} with state nosync

[Attributor] Update changed [AANoSync] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %0)' at position {cs:call [call@-1]} with state may-sync

[Attributor] Update changed [AANoSync] for CtxI '  %f = alloca %struct.Foo, align 4' at position {fn:foo [foo@-1]} with state may-sync

[Attributor] Update: [AANoFree] for CtxI '  %f = alloca %struct.Foo, align 4' at position {fn:foo [foo@-1]} with state nofree

[Attributor] Update: [AANoFree] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %0)' at position {cs:call [call@-1]} with state nofree

[Attributor] Update changed [AANoFree] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %0)' at position {cs:call [call@-1]} with state may-free

[Attributor] Update changed [AANoFree] for CtxI '  %f = alloca %struct.Foo, align 4' at position {fn:foo [foo@-1]} with state may-free

[Attributor] Update: [AANoReturn] for CtxI '  %f = alloca %struct.Foo, align 4' at position {fn:foo [foo@-1]} with state noreturn

[Attributor] Update changed [AANoReturn] for CtxI '  %f = alloca %struct.Foo, align 4' at position {fn:foo [foo@-1]} with state may-return

[Attributor] Update: [AAAssumptionInfo] for CtxI '  %f = alloca %struct.Foo, align 4' at position {fn:foo [foo@-1]} with state Known [], Assumed [Universal]

[Attributor] Function foo has no internal linkage, hence not all call sites are known
[Attributor] Update changed [AAAssumptionInfo] for CtxI '  %f = alloca %struct.Foo, align 4' at position {fn:foo [foo@-1]} with state Known [], Assumed []

[Attributor] Update: [AAAssumptionInfo] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %0)' at position {cs:call [call@-1]} with state Known [], Assumed [Universal]

[Attributor] Update changed [AAAssumptionInfo] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %0)' at position {cs:call [call@-1]} with state Known [], Assumed []

[Attributor] Update: [AAAssumptionInfo] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %0)' at position {cs:call [call@-1]} with state Known [], Assumed []

[Attributor] Update unchanged [AAAssumptionInfo] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %0)' at position {cs:call [call@-1]} with state Known [], Assumed []

[Attributor] Update: [AAAlign] for CtxI '  %a1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:a1 [a1@-1]} with state align<4-4294967296>

[Attributor] Update: [AAAlign] for CtxI '  %f = alloca %struct.Foo, align 4' at position {flt:f [f@-1]} with state align<4-4294967296>

[Attributor] Update changed [AAAlign] for CtxI '  %f = alloca %struct.Foo, align 4' at position {flt:f [f@-1]} with state align<4-4>

[Attributor] Update changed [AAAlign] for CtxI '  %a1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:a1 [a1@-1]} with state align<4-4>

[Attributor] Update: [AAAlign] for CtxI '  %a = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:a [a@-1]} with state align<4-4294967296>

[Attributor] Update changed [AAAlign] for CtxI '  %a = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:a [a@-1]} with state align<4-4>

[Attributor] Update: [AAIsDead] for CtxI '  %retval = alloca i32, align 4' at position {fn:main [main@-1]} with state Live[#BB 1/1][#TBEP 1][#KDE 0]

[AAIsDead] Live [1/1] BBs and 1 exploration points and 0 known dead ends
[AAIsDead] Exploration inst:   %retval = alloca i32, align 4
[AAIsDead] #AliveSuccessors: 1 UsedAssumedInformation: 0
[AAIsDead] Exploration inst:   ret i32 0
[AAIsDead] #AliveSuccessors: 0 UsedAssumedInformation: 0
[Attributor] Update changed [AAIsDead] for CtxI '  %retval = alloca i32, align 4' at position {fn:main [main@-1]} with state Live[#BB 1/1][#TBEP 0][#KDE 1]

[Attributor] Update: [AAUndefinedBehavior] for CtxI '  %retval = alloca i32, align 4' at position {fn:main [main@-1]} with state undefined-behavior

[Attributor] Update: [AAPotentialValues] for CtxI '  %retval = alloca i32, align 4' at position {flt:retval [retval@-1]} with state set-state(< {} >)

The instruction encountered was:   %retval = alloca i32, align 4!
The instruction Opcode was: 31!
[Attributor] Update changed [AAPotentialValues] for CtxI '  %retval = alloca i32, align 4' at position {flt:retval [retval@-1]} with state set-state(< {  %retval = alloca i32, align 4[3], } >)

[Attributor] Update: [AAMemoryBehavior] for CtxI '  call void @foo()' at position {cs: [@-1]} with state readnone

[Attributor] Update changed [AAMemoryBehavior] for CtxI '  call void @foo()' at position {cs: [@-1]} with state may-read/write

[Attributor] Update: [AAMemoryLocation] for CtxI '  call void @foo()' at position {cs: [@-1]} with state memory

[Attributor] Update changed [AAMemoryLocation] for CtxI '  call void @foo()' at position {cs: [@-1]} with state all memory

[Attributor] Update: [AAIsDead] for CtxI '  %retval = alloca i32, align 4' at position {fn_ret:main [main@-1]} with state assumed-dead

[Attributor] Function main has no internal linkage, hence not all call sites are known
[Attributor] Update changed [AAIsDead] for CtxI '  %retval = alloca i32, align 4' at position {fn_ret:main [main@-1]} with state assumed-live

[Attributor] Update: [AANoUndef] for CtxI '  %retval = alloca i32, align 4' at position {fn_ret:main [main@-1]} with state noundef

[Attributor] Clamp return value states for [AANoUndef] for CtxI '  %retval = alloca i32, align 4' at position {fn_ret:main [main@-1]} with state noundef
 into (0-1)
[Attributor] Update: [AAReturnedValues] for CtxI '  %retval = alloca i32, align 4' at position {fn:main [main@-1]} with state may-return(#0)

[Attributor] Update changed [AAReturnedValues] for CtxI '  %retval = alloca i32, align 4' at position {fn:main [main@-1]} with state may-return(#1)

[Attributor] Update: [AAReturnedValues] for CtxI '  %retval = alloca i32, align 4' at position {fn:main [main@-1]} with state may-return(#1)

[Attributor] Update unchanged [AAReturnedValues] for CtxI '  %retval = alloca i32, align 4' at position {fn:main [main@-1]} with state may-return(#1)

[Attributor] RV: i32 0 AA: noundef @ {flt: [@-1]}
[Attributor] AA State: (1-1)fix RV State: (0-1)
[Attributor] Update unchanged [AANoUndef] for CtxI '  %retval = alloca i32, align 4' at position {fn_ret:main [main@-1]} with state noundef

[Attributor] Update changed [AAUndefinedBehavior] for CtxI '  %retval = alloca i32, align 4' at position {fn:main [main@-1]} with state undefined-behavior

[Attributor] Update: [AAUndefinedBehavior] for CtxI '  %retval = alloca i32, align 4' at position {fn:main [main@-1]} with state undefined-behavior

[Attributor] Update unchanged [AAUndefinedBehavior] for CtxI '  %retval = alloca i32, align 4' at position {fn:main [main@-1]} with state undefined-behavior

[Attributor] Update: [AAHeapToStack] for CtxI '  %retval = alloca i32, align 4' at position {fn:main [main@-1]} with state [H2S] Mallocs Good/Bad: 0/0

[Attributor] Update unchanged [AAHeapToStack] for CtxI '  %retval = alloca i32, align 4' at position {fn:main [main@-1]} with state [H2S] Mallocs Good/Bad: 0/0

[Attributor] Update: [AAWillReturn] for CtxI '  %retval = alloca i32, align 4' at position {fn:main [main@-1]} with state willreturn

[Attributor] Update: [AAWillReturn] for CtxI '  call void @foo()' at position {cs: [@-1]} with state willreturn

[Attributor] Update changed [AAWillReturn] for CtxI '  call void @foo()' at position {cs: [@-1]} with state may-noreturn

[Attributor] Update changed [AAWillReturn] for CtxI '  %retval = alloca i32, align 4' at position {fn:main [main@-1]} with state may-noreturn

[Attributor] Update: [AAMustProgress] for CtxI '  %retval = alloca i32, align 4' at position {fn:main [main@-1]} with state mustprogress

[Attributor] Function main has no internal linkage, hence not all call sites are known
[Attributor] Update changed [AAMustProgress] for CtxI '  %retval = alloca i32, align 4' at position {fn:main [main@-1]} with state may-not-progress

[Attributor] Update: [AANoSync] for CtxI '  %retval = alloca i32, align 4' at position {fn:main [main@-1]} with state nosync

[Attributor] Update: [AAIsDead] for CtxI '  store i32 0, ptr %retval, align 4' at position {flt: [@-1]} with state assumed-dead-store

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 0, ptr %retval, align 4 (only exact: 0)
[Attributor] Update: [AAUnderlyingObjects] for CtxI '  %retval = alloca i32, align 4' at position {flt:retval [retval@-1]} with state UnderlyingObjects inter #0 objs, intra #0 objs

[Attributor] Update changed [AAUnderlyingObjects] for CtxI '  %retval = alloca i32, align 4' at position {flt:retval [retval@-1]} with state UnderlyingObjects inter #1 objs, intra #1 objs

[Attributor] Update: [AAUnderlyingObjects] for CtxI '  %retval = alloca i32, align 4' at position {flt:retval [retval@-1]} with state UnderlyingObjects inter #1 objs, intra #1 objs

[Attributor] Update unchanged [AAUnderlyingObjects] for CtxI '  %retval = alloca i32, align 4' at position {flt:retval [retval@-1]} with state UnderlyingObjects inter #1 objs, intra #1 objs

Visit underlying object   %retval = alloca i32, align 4
Reached here!
[Attributor] Update: [AAPointerInfo] for CtxI '  %retval = alloca i32, align 4' at position {flt:retval [retval@-1]} with state PointerInfo #0 bins

[Attributor] Got 1 initial uses to check
[AAPointerInfo] Analyze   %retval = alloca i32, align 4 in   store i32 0, ptr %retval, align 4
[AAPointerInfo] Inserting access in new offset bins
    key [0, 4]
Accesses by bin after update:
[0-4] : 1
     - 9 -   store i32 0, ptr %retval, align 4
       - c: i32 0
[Attributor] Update changed [AAPointerInfo] for CtxI '  %retval = alloca i32, align 4' at position {flt:retval [retval@-1]} with state PointerInfo #1 bins

[Attributor] Update: [AAPointerInfo] for CtxI '  %retval = alloca i32, align 4' at position {flt:retval [retval@-1]} with state PointerInfo #1 bins

[Attributor] Got 1 initial uses to check
[AAPointerInfo] Analyze   %retval = alloca i32, align 4 in   store i32 0, ptr %retval, align 4
Accesses by bin after update:
[0-4] : 1
     - 9 -   store i32 0, ptr %retval, align 4
       - c: i32 0
[Attributor] Update unchanged [AAPointerInfo] for CtxI '  %retval = alloca i32, align 4' at position {flt:retval [retval@-1]} with state PointerInfo #1 bins

[Attributor] Update: [AANoCapture] for CtxI '  %retval = alloca i32, align 4' at position {flt:retval [retval@-1]} with state assumed not-captured

[Attributor] Update: [AAMemoryBehavior] for CtxI '  %retval = alloca i32, align 4' at position {fn:main [main@-1]} with state readnone

[Attributor] Update changed [AAMemoryBehavior] for CtxI '  %retval = alloca i32, align 4' at position {fn:main [main@-1]} with state may-read/write

[Attributor] Update: [AAMemoryLocation] for CtxI '  %retval = alloca i32, align 4' at position {fn:main [main@-1]} with state memory

[AAMemoryLocation] Categorize accessed locations for   store i32 0, ptr %retval, align 4
[AAMemoryLocation] Categorize memory access with pointer:   store i32 0, ptr %retval, align 4 [  %retval = alloca i32, align 4]
[AAMemoryLocation] Categorize pointer locations for   %retval = alloca i32, align 4 [no memory]
[AAMemoryLocation] Ptr value can be categorized:   %retval = alloca i32, align 4 -> memory:constant,internal global,external global,argument,inaccessible,malloced,unknown
[AAMemoryLocation] Accessed locations with pointer locations: memory:stack
[AAMemoryLocation] Accessed locations for   store i32 0, ptr %retval, align 4: memory:stack
[AAMemoryLocation] Categorize accessed locations for   call void @foo()
[AAMemoryLocation] Categorize call site:   call void @foo() [0x55df32883260]
[AAMemoryLocation] Accessed locations for   call void @foo(): all memory
[Attributor] Update changed [AAMemoryLocation] for CtxI '  %retval = alloca i32, align 4' at position {fn:main [main@-1]} with state all memory

[Attributor] Got 1 initial uses to check
[Attributor] Update unchanged [AANoCapture] for CtxI '  %retval = alloca i32, align 4' at position {flt:retval [retval@-1]} with state assumed not-captured

[AA] Object '  %retval = alloca i32, align 4' is  thread local; non-captured stack object.
[Attributor] Update: [AANoRecurse] for CtxI '  %retval = alloca i32, align 4' at position {fn:main [main@-1]} with state norecurse

[Attributor] Function main has no internal linkage, hence not all call sites are known
[Attributor] Update: [AAInterFnReachability] for CtxI '  %retval = alloca i32, align 4' at position {fn:main [main@-1]} with state #queries(0)

[Attributor] Update unchanged [AAInterFnReachability] for CtxI '  %retval = alloca i32, align 4' at position {fn:main [main@-1]} with state #queries(0)

[Attributor] Update: [AAIntraFnReachability] for CtxI '  %retval = alloca i32, align 4' at position {fn:main [main@-1]} with state #queries(0)

[Attributor] Update unchanged [AAIntraFnReachability] for CtxI '  %retval = alloca i32, align 4' at position {fn:main [main@-1]} with state #queries(0)

[Attributor] Update: [AACallEdges] for CtxI '  call void @foo()' at position {cs: [@-1]} with state CallEdges[0,0]

[AACallEdges] New call edge: foo
[Attributor] Update changed [AACallEdges] for CtxI '  call void @foo()' at position {cs: [@-1]} with state CallEdges[0,1]

[Attributor] Update: [AACallEdges] for CtxI '  call void @foo()' at position {cs: [@-1]} with state CallEdges[0,1]

[Attributor] Update unchanged [AACallEdges] for CtxI '  call void @foo()' at position {cs: [@-1]} with state CallEdges[0,1]

[Attributor] Update changed [AANoRecurse] for CtxI '  %retval = alloca i32, align 4' at position {fn:main [main@-1]} with state may-recurse

[AAIsDead] Store has 0 potential copies.
[Attributor] Update unchanged [AAIsDead] for CtxI '  store i32 0, ptr %retval, align 4' at position {flt: [@-1]} with state assumed-dead-store

[Attributor] Update: [AANoSync] for CtxI '  call void @foo()' at position {cs: [@-1]} with state nosync

[Attributor] Update changed [AANoSync] for CtxI '  call void @foo()' at position {cs: [@-1]} with state may-sync

[Attributor] Update changed [AANoSync] for CtxI '  %retval = alloca i32, align 4' at position {fn:main [main@-1]} with state may-sync

[Attributor] Update: [AANoFree] for CtxI '  %retval = alloca i32, align 4' at position {fn:main [main@-1]} with state nofree

[Attributor] Update: [AANoFree] for CtxI '  call void @foo()' at position {cs: [@-1]} with state nofree

[Attributor] Update changed [AANoFree] for CtxI '  call void @foo()' at position {cs: [@-1]} with state may-free

[Attributor] Update changed [AANoFree] for CtxI '  %retval = alloca i32, align 4' at position {fn:main [main@-1]} with state may-free

[Attributor] Update: [AANoReturn] for CtxI '  %retval = alloca i32, align 4' at position {fn:main [main@-1]} with state noreturn

[Attributor] Update changed [AANoReturn] for CtxI '  %retval = alloca i32, align 4' at position {fn:main [main@-1]} with state may-return

[Attributor] Update: [AAAssumptionInfo] for CtxI '  %retval = alloca i32, align 4' at position {fn:main [main@-1]} with state Known [], Assumed [Universal]

[Attributor] Function main has no internal linkage, hence not all call sites are known
[Attributor] Update changed [AAAssumptionInfo] for CtxI '  %retval = alloca i32, align 4' at position {fn:main [main@-1]} with state Known [], Assumed []

[Attributor] Update: [AAPotentialValues] for CtxI '  %retval = alloca i32, align 4' at position {fn_ret:main [main@-1]} with state set-state(< {} >)

[Attributor] Clamp return value states for [AAPotentialValues] for CtxI '  %retval = alloca i32, align 4' at position {fn_ret:main [main@-1]} with state set-state(< {} >)
 into set-state(< {} >)
[Attributor] RV: i32 0 AA: set-state(< {i32 0[3], } >) @ {flt: [@-1]}
[Attributor] AA State: set-state(< {i32 0[3], } >) RV State: set-state(< {i32 0[3], } >)
[Attributor] Update changed [AAPotentialValues] for CtxI '  %retval = alloca i32, align 4' at position {fn_ret:main [main@-1]} with state set-state(< {i32 0[3], } >)

[Attributor] Update: [AAPotentialValues] for CtxI '  %retval = alloca i32, align 4' at position {fn_ret:main [main@-1]} with state set-state(< {i32 0[3], } >)

[Attributor] Clamp return value states for [AAPotentialValues] for CtxI '  %retval = alloca i32, align 4' at position {fn_ret:main [main@-1]} with state set-state(< {i32 0[3], } >)
 into set-state(< {} >)
[Attributor] RV: i32 0 AA: set-state(< {i32 0[3], } >) @ {flt: [@-1]}
[Attributor] AA State: set-state(< {i32 0[3], } >) RV State: set-state(< {i32 0[3], } >)
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %retval = alloca i32, align 4' at position {fn_ret:main [main@-1]} with state set-state(< {i32 0[3], } >)

[Attributor] Update: [AAAssumptionInfo] for CtxI '  call void @foo()' at position {cs: [@-1]} with state Known [], Assumed [Universal]

[Attributor] Update changed [AAAssumptionInfo] for CtxI '  call void @foo()' at position {cs: [@-1]} with state Known [], Assumed []

[Attributor] Update: [AAAssumptionInfo] for CtxI '  call void @foo()' at position {cs: [@-1]} with state Known [], Assumed []

[Attributor] Update unchanged [AAAssumptionInfo] for CtxI '  call void @foo()' at position {cs: [@-1]} with state Known [], Assumed []

[Attributor] Update: [AAAlign] for CtxI '  %retval = alloca i32, align 4' at position {flt:retval [retval@-1]} with state align<4-4294967296>

[Attributor] Update changed [AAAlign] for CtxI '  %retval = alloca i32, align 4' at position {flt:retval [retval@-1]} with state align<4-4>

[Attributor] Identified and initialized 91 abstract attributes.


[Attributor] #Iteration: 1, Worklist size: 91
[Attributor] #Iteration: 1, Worklist+Dependent size: 91
[Attributor] Update: [AAIsDead] for CtxI '  store i32 10, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead-store

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 10, ptr %a, align 4 (only exact: 0)
Visit underlying object   %f = alloca %struct.Foo, align 4
Reached here!
[AA] Object '  %f = alloca %struct.Foo, align 4' is  thread local; non-captured stack object.
[AA] check   %0 = load i32, ptr %a1, align 4 from   store i32 10, ptr %a, align 4 intraprocedurally
[AA]   store i32 10, ptr %a, align 4 can potentially reach   %0 = load i32, ptr %a1, align 4 [Intra]
[AAIsDead] Store has 1 potential copies.
[Attributor] Update unchanged [AAIsDead] for CtxI '  store i32 10, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead-store

[Attributor] Update: [AANoCapture] for CtxI '  %f = alloca %struct.Foo, align 4' at position {flt:f [f@-1]} with state assumed not-captured

[Attributor] Got 2 initial uses to check
[Attributor] Update unchanged [AANoCapture] for CtxI '  %f = alloca %struct.Foo, align 4' at position {flt:f [f@-1]} with state assumed not-captured

[Attributor] Update: [AAIsDead] for CtxI '  %0 = load i32, ptr %a1, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Update unchanged [AAIsDead] for CtxI '  %0 = load i32, ptr %a1, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Update: [AAPotentialValues] for CtxI '  %0 = load i32, ptr %a1, align 4' at position {flt: [@-1]} with state set-state(< {i32 10[3], } >)

The instruction encountered was:   %0 = load i32, ptr %a1, align 4!
The instruction Opcode was: 32!
getPotentiallyLoadedValues!
Trying to determine the potential copies of   %0 = load i32, ptr %a1, align 4 (only exact: 1)
Visit underlying object   %f = alloca %struct.Foo, align 4
Reached here!
[AA] Object '  %f = alloca %struct.Foo, align 4' is  thread local; non-captured stack object.
[AA] check   %0 = load i32, ptr %a1, align 4 from   store i32 10, ptr %a, align 4 intraprocedurally
[AA]   store i32 10, ptr %a, align 4 can potentially reach   %0 = load i32, ptr %a1, align 4 [Intra]
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %0 = load i32, ptr %a1, align 4' at position {flt: [@-1]} with state set-state(< {i32 10[3], } >)

[Attributor] Update: [AAInterFnReachability] for CtxI '  %f = alloca %struct.Foo, align 4' at position {fn:foo [foo@-1]} with state #queries(2)

[Attributor] Update unchanged [AAInterFnReachability] for CtxI '  %f = alloca %struct.Foo, align 4' at position {fn:foo [foo@-1]} with state #queries(2)

[Attributor] Update: [AAIntraFnReachability] for CtxI '  %f = alloca %struct.Foo, align 4' at position {fn:foo [foo@-1]} with state #queries(2)

[Attributor] Update unchanged [AAIntraFnReachability] for CtxI '  %f = alloca %struct.Foo, align 4' at position {fn:foo [foo@-1]} with state #queries(2)

[Attributor] Update: [AAIsDead] for CtxI '  %a1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:a1 [a1@-1]} with state assumed-dead

[Attributor] Got 1 initial uses to check
[Attributor] Update unchanged [AAIsDead] for CtxI '  %a1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:a1 [a1@-1]} with state assumed-dead

[Attributor] Update: [AAIsDead] for CtxI '  store i32 0, ptr %retval, align 4' at position {flt: [@-1]} with state assumed-dead-store

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 0, ptr %retval, align 4 (only exact: 0)
Visit underlying object   %retval = alloca i32, align 4
Reached here!
[AA] Object '  %retval = alloca i32, align 4' is  thread local; non-captured stack object.
[AAIsDead] Store has 0 potential copies.
[Attributor] Update unchanged [AAIsDead] for CtxI '  store i32 0, ptr %retval, align 4' at position {flt: [@-1]} with state assumed-dead-store

[Attributor] Update: [AAInterFnReachability] for CtxI '  %retval = alloca i32, align 4' at position {fn:main [main@-1]} with state #queries(1)

[Attributor] Update unchanged [AAInterFnReachability] for CtxI '  %retval = alloca i32, align 4' at position {fn:main [main@-1]} with state #queries(1)

[Attributor] Update: [AAIntraFnReachability] for CtxI '  %retval = alloca i32, align 4' at position {fn:main [main@-1]} with state #queries(1)

[Attributor] Update unchanged [AAIntraFnReachability] for CtxI '  %retval = alloca i32, align 4' at position {fn:main [main@-1]} with state #queries(1)


[Attributor] Fixpoint iteration done after: 1/32 iterations
[Attributor] Manifest unchanged : [AAUndefinedBehavior] for CtxI '  %f = alloca %struct.Foo, align 4' at position {fn:foo [foo@-1]} with state undefined-behavior

[Attributor] Manifest changed : [AAPotentialValues] for CtxI '  %a1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:a1 [a1@-1]} with state set-state(< {  %f = alloca %struct.Foo, align 4[3], } >)

[Attributor] Manifest unchanged : [AAPotentialValues] for CtxI <<null inst>> at position {flt: [@-1]} with state set-state(< {i32 1[3], } >)

[Attributor] Manifest unchanged : [AAPotentialValues] for CtxI '  %f = alloca %struct.Foo, align 4' at position {flt:f [f@-1]} with state set-state(< {  %f = alloca %struct.Foo, align 4[3], } >)

[Attributor] Manifest changed : [AAPotentialValues] for CtxI '  %a = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:a [a@-1]} with state set-state(< {  %f = alloca %struct.Foo, align 4[3], } >)

[Attributor] Manifest unchanged : [AANoUndef] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %0)' at position {cs_arg:.str [call@0]} with state noundef

[Attributor] Manifest unchanged : [AAPotentialValues] for CtxI <<null inst>> at position {flt:.str [.str@-1]} with state set-state(< {@.str = private unnamed_addr constant [15 x i8] c"field a is %d\0A\00", align 1[3], } >)

[Attributor] Manifest unchanged : [AAHeapToStack] for CtxI '  %f = alloca %struct.Foo, align 4' at position {fn:foo [foo@-1]} with state [H2S] Mallocs Good/Bad: 0/0

[AAIsDead] Store has 1 potential copies.
[Attributor] Manifest changed : [AAIsDead] for CtxI '  store i32 10, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead-store

[Attributor] Manifest unchanged : [AAUnderlyingObjects] for CtxI '  %a = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:a [a@-1]} with state UnderlyingObjects inter #1 objs, intra #1 objs

[Attributor] Manifest unchanged : [AAPointerInfo] for CtxI '  %f = alloca %struct.Foo, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

[Attributor] Manifest unchanged : [AAPotentialValues] for CtxI <<null inst>> at position {flt: [@-1]} with state set-state(< {i32 10[3], } >)

[Attributor] Manifest unchanged : [AANoCapture] for CtxI '  %f = alloca %struct.Foo, align 4' at position {flt:f [f@-1]} with state known not-captured

[Attributor] Manifest changed : [AAIsDead] for CtxI '  %0 = load i32, ptr %a1, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Manifest changed : [AAPotentialValues] for CtxI '  %0 = load i32, ptr %a1, align 4' at position {flt: [@-1]} with state set-state(< {i32 10[3], } >)

[Attributor] Manifest unchanged : [AAUnderlyingObjects] for CtxI '  %a1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:a1 [a1@-1]} with state UnderlyingObjects inter #1 objs, intra #1 objs

[Attributor] Manifest unchanged : [AAInterFnReachability] for CtxI '  %f = alloca %struct.Foo, align 4' at position {fn:foo [foo@-1]} with state #queries(2)

[Attributor] Manifest unchanged : [AAIntraFnReachability] for CtxI '  %f = alloca %struct.Foo, align 4' at position {fn:foo [foo@-1]} with state #queries(2)

[Attributor] Manifest unchanged : [AACallEdges] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %0)' at position {cs:call [call@-1]} with state CallEdges[0,1]

[Attributor] Manifest unchanged : [AAPotentialValues] for CtxI <<null inst>> at position {flt:printf [printf@-1]} with state set-state(< {@printf[3], } >)

[Attributor] Manifest unchanged : [AAInstanceInfo] for CtxI <<null inst>> at position {flt: [@-1]} with state <unique [fAa]>

[Attributor] Manifest changed : [AAIsDead] for CtxI '  %a1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:a1 [a1@-1]} with state assumed-dead

[Attributor] Manifest unchanged : [AAAlign] for CtxI '  %a1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:a1 [a1@-1]} with state align<4-4>

[Attributor] Manifest unchanged : [AAAlign] for CtxI '  %f = alloca %struct.Foo, align 4' at position {flt:f [f@-1]} with state align<4-4>

[Attributor] Manifest unchanged : [AAAlign] for CtxI '  %a = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:a [a@-1]} with state align<4-4>

[Attributor] Manifest unchanged : [AAUndefinedBehavior] for CtxI '  %retval = alloca i32, align 4' at position {fn:main [main@-1]} with state undefined-behavior

[Attributor] Manifest unchanged : [AAPotentialValues] for CtxI '  %retval = alloca i32, align 4' at position {flt:retval [retval@-1]} with state set-state(< {  %retval = alloca i32, align 4[3], } >)

[Attributor] Manifest unchanged : [AANoUnwind] for CtxI '  call void @foo()' at position {cs: [@-1]} with state nounwind

[Attributor] Manifest changed : [AANoUndef] for CtxI '  %retval = alloca i32, align 4' at position {fn_ret:main [main@-1]} with state noundef

[Attributor] Manifest unchanged : [AAReturnedValues] for CtxI '  %retval = alloca i32, align 4' at position {fn:main [main@-1]} with state returns(#1)

[Attributor] Manifest unchanged : [AAPotentialValues] for CtxI <<null inst>> at position {flt: [@-1]} with state set-state(< {i32 0[3], } >)

[Attributor] Manifest unchanged : [AANoUndef] for CtxI <<null inst>> at position {flt: [@-1]} with state noundef

[Attributor] Manifest unchanged : [AAHeapToStack] for CtxI '  %retval = alloca i32, align 4' at position {fn:main [main@-1]} with state [H2S] Mallocs Good/Bad: 0/0

[AAIsDead] Store has 0 potential copies.
[Attributor] Manifest changed : [AAIsDead] for CtxI '  store i32 0, ptr %retval, align 4' at position {flt: [@-1]} with state assumed-dead-store

[Attributor] Manifest unchanged : [AAUnderlyingObjects] for CtxI '  %retval = alloca i32, align 4' at position {flt:retval [retval@-1]} with state UnderlyingObjects inter #1 objs, intra #1 objs

[Attributor] Manifest unchanged : [AAPointerInfo] for CtxI '  %retval = alloca i32, align 4' at position {flt:retval [retval@-1]} with state PointerInfo #1 bins

[Attributor] Manifest unchanged : [AANoCapture] for CtxI '  %retval = alloca i32, align 4' at position {flt:retval [retval@-1]} with state known not-captured

[Attributor] Manifest unchanged : [AAInterFnReachability] for CtxI '  %retval = alloca i32, align 4' at position {fn:main [main@-1]} with state #queries(1)

[Attributor] Manifest unchanged : [AAIntraFnReachability] for CtxI '  %retval = alloca i32, align 4' at position {fn:main [main@-1]} with state #queries(1)

[Attributor] Manifest unchanged : [AACallEdges] for CtxI '  call void @foo()' at position {cs: [@-1]} with state CallEdges[0,1]

[Attributor] Manifest unchanged : [AAPotentialValues] for CtxI '  %f = alloca %struct.Foo, align 4' at position {flt:foo [foo@-1]} with state set-state(< {@foo[3], } >)

[Attributor] Manifest unchanged : [AAPotentialValues] for CtxI '  %retval = alloca i32, align 4' at position {fn_ret:main [main@-1]} with state set-state(< {i32 0[3], } >)

[Attributor] Manifest unchanged : [AAAlign] for CtxI '  %retval = alloca i32, align 4' at position {flt:retval [retval@-1]} with state align<4-4>


[Attributor] Manifested 8 arguments while 43 were in a valid fixpoint state

[Attributor] Delete/replace at least 0 functions and 0 blocks and 4 instructions and 3 values and 0 uses. To insert 0 unreachables.
Preserve manifest added 0 blocks
Use   %f = alloca %struct.Foo, align 4 in   %0 = load i32, ptr %a1, align 4 instead of   %a1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
Use   %f = alloca %struct.Foo, align 4 in   store i32 10, ptr %a, align 4 instead of   %a = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
Use i32 10 in   %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %0) instead of   %0 = load i32, ptr %f, align 4
[Attributor] DeadInsts size: 3
  -   %a = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
  -   %0 = load i32, ptr %f, align 4
  -   %a1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[Attributor] Deleted 0 functions after manifest.
[Attributor] Done with 3 functions, result: changed.
