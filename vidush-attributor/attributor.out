[Attributor] Run on module with 3 functions:
  - foo
  - printf
  - main
[Attributor] Update: [AAIsDead] for CtxI '  %val.addr = alloca i32, align 4' at position {fn:foo [foo@-1]} with state Live[#BB 1/1][#TBEP 1][#KDE 0]

[AAIsDead] Live [1/1] BBs and 1 exploration points and 0 known dead ends
[AAIsDead] Exploration inst:   %val.addr = alloca i32, align 4
[AAIsDead] #AliveSuccessors: 1 UsedAssumedInformation: 0
[AAIsDead] Exploration inst:   ret void
[AAIsDead] #AliveSuccessors: 0 UsedAssumedInformation: 0
[Attributor] Update changed [AAIsDead] for CtxI '  %val.addr = alloca i32, align 4' at position {fn:foo [foo@-1]} with state Live[#BB 1/1][#TBEP 0][#KDE 1]

[Attributor] Update: [AAUndefinedBehavior] for CtxI '  %val.addr = alloca i32, align 4' at position {fn:foo [foo@-1]} with state undefined-behavior

[Attributor] Update: [AAPotentialValues] for CtxI '  %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field11 [field11@-1]} with state set-state(< {} >)

The instruction encountered was:   %f = alloca %struct.Foo, align 4!
The instruction Opcode was: 31!
[Attributor] Update: [AAPointerInfo] for CtxI '  %f = alloca %struct.Foo, align 4' at position {flt:f [f@-1]} with state PointerInfo #0 bins

[Attributor] Got 5 initial uses to check
[AAPointerInfo] Analyze   %f = alloca %struct.Foo, align 4 in   %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] GEP offset is  constant   %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] Analyze   %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   store i32 10, ptr %field1, align 4
[AAPointerInfo] Inserting access in new offset bins
    key [0, 4]
[AAPointerInfo] Analyze   %f = alloca %struct.Foo, align 4 in   %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] GEP offset is  constant   %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] Analyze   %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   %0 = load i32, ptr %field11, align 4
[AAPointerInfo] Inserting access in new offset bins
    key [0, 4]
[AAPointerInfo] Analyze   %f = alloca %struct.Foo, align 4 in   %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] GEP offset is  constant   %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] Analyze   %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   store i32 %2, ptr %field12, align 4
[Attributor] Update: [AAPotentialValues] for CtxI '  %2 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state set-state(< {} >)

getPotentiallyLoadedValues!
Trying to determine the potential copies of   %2 = load i32, ptr %a, align 4 (only exact: 1)
[Attributor] Update: [AAUnderlyingObjects] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state UnderlyingObjects inter #0 objs, intra #0 objs

[Attributor] Update: [AAPotentialValues] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state set-state(< {} >)

The instruction encountered was:   %a = alloca i32, align 4!
The instruction Opcode was: 31!
[Attributor] Update: [AAPointerInfo] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state PointerInfo #0 bins

[Attributor] Got 4 initial uses to check
[AAPointerInfo] Analyze   %a = alloca i32, align 4 in   store i32 %0, ptr %a, align 4
[Attributor] Update: [AAPotentialValues] for CtxI '  %0 = load i32, ptr %field11, align 4' at position {flt: [@-1]} with state set-state(< {} >)

getPotentiallyLoadedValues!
Trying to determine the potential copies of   %0 = load i32, ptr %field11, align 4 (only exact: 1)
[Attributor] Update: [AAUnderlyingObjects] for CtxI '  %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field11 [field11@-1]} with state UnderlyingObjects inter #0 objs, intra #0 objs

[Attributor] Update unchanged [AAUnderlyingObjects] for CtxI '  %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field11 [field11@-1]} with state UnderlyingObjects inter #0 objs, intra #0 objs

[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %0 = load i32, ptr %field11, align 4' at position {flt: [@-1]} with state set-state(< {} >)

[AAPointerInfo] Inserting access in new offset bins
    key [0, 4]
[AAPointerInfo] Analyze   %a = alloca i32, align 4 in   %1 = load i32, ptr %a, align 4
[AAPointerInfo] Inserting access in new offset bins
    key [0, 4]
[AAPointerInfo] Analyze   %a = alloca i32, align 4 in   store i32 %add, ptr %a, align 4
[Attributor] Update: [AAPotentialValues] for CtxI '  %add = add nsw i32 %1, 1' at position {flt:add [add@-1]} with state set-state(< {} >)

[Attributor] Update: [AAPotentialValues] for CtxI '  %1 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state set-state(< {} >)

getPotentiallyLoadedValues!
Trying to determine the potential copies of   %1 = load i32, ptr %a, align 4 (only exact: 1)
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %1 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state set-state(< {} >)

[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %add = add nsw i32 %1, 1' at position {flt:add [add@-1]} with state set-state(< {} >)

[AAPointerInfo] Inserting access in new offset bins
    key [0, 4]
[AAPointerInfo] Analyze   %a = alloca i32, align 4 in   %2 = load i32, ptr %a, align 4
[AAPointerInfo] Inserting access in new offset bins
    key [0, 4]
Accesses by bin after update:
[0-4] : 4
     - 9 -   store i32 %0, ptr %a, align 4
     - 5 -   %1 = load i32, ptr %a, align 4
       - c: <unknown>
     - 9 -   store i32 %add, ptr %a, align 4
     - 5 -   %2 = load i32, ptr %a, align 4
       - c: <unknown>
[Attributor] Update changed [AAPointerInfo] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state PointerInfo #1 bins

Was able to create AAPointer Info object [AAPointerInfo] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state PointerInfo #1 bins

[handleAllocaInst] The first offset is the start of the Alloca.
[handleAllocaInst] Offset size cannot be reduced in Alloca.
[Attributor] Update changed [AAPotentialValues] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state set-state(< {  %a = alloca i32, align 4[3], } >)

[Attributor] Update changed [AAUnderlyingObjects] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state UnderlyingObjects inter #1 objs, intra #1 objs

[Attributor] Update: [AAUnderlyingObjects] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state UnderlyingObjects inter #1 objs, intra #1 objs

[Attributor] Update unchanged [AAUnderlyingObjects] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state UnderlyingObjects inter #1 objs, intra #1 objs

Visit underlying object   %a = alloca i32, align 4
[Attributor] Update: [AANoSync] for CtxI '  %val.addr = alloca i32, align 4' at position {fn:foo [foo@-1]} with state nosync

[Attributor] Update: [AAIsDead] for CtxI '  store i32 %val, ptr %val.addr, align 4' at position {flt: [@-1]} with state assumed-dead-store

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 %val, ptr %val.addr, align 4 (only exact: 0)
[Attributor] Update: [AAUnderlyingObjects] for CtxI '  %val.addr = alloca i32, align 4' at position {flt:val.addr [val.addr@-1]} with state UnderlyingObjects inter #0 objs, intra #0 objs

[Attributor] Update: [AAPotentialValues] for CtxI '  %val.addr = alloca i32, align 4' at position {flt:val.addr [val.addr@-1]} with state set-state(< {} >)

The instruction encountered was:   %val.addr = alloca i32, align 4!
The instruction Opcode was: 31!
[Attributor] Update: [AAPointerInfo] for CtxI '  %val.addr = alloca i32, align 4' at position {flt:val.addr [val.addr@-1]} with state PointerInfo #0 bins

[Attributor] Got 2 initial uses to check
[AAPointerInfo] Analyze   %val.addr = alloca i32, align 4 in   store i32 %val, ptr %val.addr, align 4
[Attributor] Update: [AAPotentialValues] for CtxI '  %val.addr = alloca i32, align 4' at position {arg:val [val@0]} with state set-state(< {} >)

[Attributor] Function foo has no internal linkage, hence not all call sites are known
[Attributor] Update changed [AAPotentialValues] for CtxI '  %val.addr = alloca i32, align 4' at position {arg:val [val@0]} with state set-state(< {i32 %val[3], } >)

[AAPointerInfo] Inserting access in new offset bins
    key [0, 4]
[AAPointerInfo] Analyze   %val.addr = alloca i32, align 4 in   %5 = load i32, ptr %val.addr, align 4
[AAPointerInfo] Inserting access in new offset bins
    key [0, 4]
Accesses by bin after update:
[0-4] : 2
     - 9 -   store i32 %val, ptr %val.addr, align 4
       - c: i32 %val
     - 5 -   %5 = load i32, ptr %val.addr, align 4
       - c: <unknown>
[Attributor] Update changed [AAPointerInfo] for CtxI '  %val.addr = alloca i32, align 4' at position {flt:val.addr [val.addr@-1]} with state PointerInfo #1 bins

[Attributor] Update: [AAPointerInfo] for CtxI '  %val.addr = alloca i32, align 4' at position {flt:val.addr [val.addr@-1]} with state PointerInfo #1 bins

[Attributor] Got 2 initial uses to check
[AAPointerInfo] Analyze   %val.addr = alloca i32, align 4 in   store i32 %val, ptr %val.addr, align 4
[AAPointerInfo] Analyze   %val.addr = alloca i32, align 4 in   %5 = load i32, ptr %val.addr, align 4
Accesses by bin after update:
[0-4] : 2
     - 9 -   store i32 %val, ptr %val.addr, align 4
       - c: i32 %val
     - 5 -   %5 = load i32, ptr %val.addr, align 4
       - c: <unknown>
[Attributor] Update unchanged [AAPointerInfo] for CtxI '  %val.addr = alloca i32, align 4' at position {flt:val.addr [val.addr@-1]} with state PointerInfo #1 bins

Was able to create AAPointer Info object [AAPointerInfo] for CtxI '  %val.addr = alloca i32, align 4' at position {flt:val.addr [val.addr@-1]} with state PointerInfo #1 bins

[handleAllocaInst] The first offset is the start of the Alloca.
[handleAllocaInst] Offset size cannot be reduced in Alloca.
[Attributor] Update changed [AAPotentialValues] for CtxI '  %val.addr = alloca i32, align 4' at position {flt:val.addr [val.addr@-1]} with state set-state(< {  %val.addr = alloca i32, align 4[3], } >)

[Attributor] Update changed [AAUnderlyingObjects] for CtxI '  %val.addr = alloca i32, align 4' at position {flt:val.addr [val.addr@-1]} with state UnderlyingObjects inter #1 objs, intra #1 objs

[Attributor] Update: [AAUnderlyingObjects] for CtxI '  %val.addr = alloca i32, align 4' at position {flt:val.addr [val.addr@-1]} with state UnderlyingObjects inter #1 objs, intra #1 objs

[Attributor] Update unchanged [AAUnderlyingObjects] for CtxI '  %val.addr = alloca i32, align 4' at position {flt:val.addr [val.addr@-1]} with state UnderlyingObjects inter #1 objs, intra #1 objs

Visit underlying object   %val.addr = alloca i32, align 4
[Attributor] Update: [AANoCapture] for CtxI '  %val.addr = alloca i32, align 4' at position {flt:val.addr [val.addr@-1]} with state assumed not-captured

[Attributor] Update: [AAMemoryBehavior] for CtxI '  %val.addr = alloca i32, align 4' at position {fn:foo [foo@-1]} with state readnone

[Attributor] Update: [AAIsDead] for CtxI '  store i32 10, ptr %field1, align 4' at position {flt: [@-1]} with state assumed-dead-store

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 10, ptr %field1, align 4 (only exact: 0)
[Attributor] Update: [AAUnderlyingObjects] for CtxI '  %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field1 [field1@-1]} with state UnderlyingObjects inter #0 objs, intra #0 objs

[Attributor] Update: [AAPotentialValues] for CtxI '  %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field1 [field1@-1]} with state set-state(< {} >)

The instruction encountered was:   %f = alloca %struct.Foo, align 4!
The instruction Opcode was: 31!
Was able to create AAPointer Info object [AAPointerInfo] for CtxI '  %f = alloca %struct.Foo, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

[handleAllocaInst] The first offset is the start of the Alloca.
Function end [handleAllocaInst] 
[Attributor] Update: [AAPotentialValues] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state set-state(< {} >)

The instruction encountered was:   %f = alloca i32, align 4!
The instruction Opcode was: 31!
Was able to create AAPointer Info object [AAPointerInfo] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

[handleAllocaInst] The first offset is the start of the Alloca.
[handleAllocaInst] Offset size cannot be reduced in Alloca.
[Attributor] Update changed [AAPotentialValues] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

[Attributor] Update changed [AAPotentialValues] for CtxI '  %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field1 [field1@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

[Attributor] Update changed [AAUnderlyingObjects] for CtxI '  %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field1 [field1@-1]} with state UnderlyingObjects inter #1 objs, intra #1 objs

Visit underlying object   %f = alloca i32, align 4
[Attributor] Update: [AANoCapture] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state assumed not-captured

[Attributor] Update: [AAMemoryLocation] for CtxI '  %val.addr = alloca i32, align 4' at position {fn:foo [foo@-1]} with state memory

[AAMemoryLocation] Categorize accessed locations for   store i32 %val, ptr %val.addr, align 4
[AAMemoryLocation] Categorize memory access with pointer:   store i32 %val, ptr %val.addr, align 4 [  %val.addr = alloca i32, align 4]
[AAMemoryLocation] Categorize pointer locations for   %val.addr = alloca i32, align 4 [no memory]
[AAMemoryLocation] Ptr value can be categorized:   %val.addr = alloca i32, align 4 -> memory:constant,internal global,external global,argument,inaccessible,malloced,unknown
[AAMemoryLocation] Accessed locations with pointer locations: memory:stack
[AAMemoryLocation] Accessed locations for   store i32 %val, ptr %val.addr, align 4: memory:stack
[AAMemoryLocation] Categorize accessed locations for   store i32 10, ptr %field1, align 4
[AAMemoryLocation] Categorize memory access with pointer:   store i32 10, ptr %field1, align 4 [  %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0]
[AAMemoryLocation] Categorize pointer locations for   %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 [no memory]
[AAMemoryLocation] Ptr value can be categorized:   %f = alloca i32, align 4 -> memory:constant,internal global,external global,argument,inaccessible,malloced,unknown
[AAMemoryLocation] Accessed locations with pointer locations: memory:stack
[AAMemoryLocation] Accessed locations for   store i32 10, ptr %field1, align 4: memory:stack
[Attributor] Update: [AAIsDead] for CtxI '  %0 = load i32, ptr %field11, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Update unchanged [AAIsDead] for CtxI '  %0 = load i32, ptr %field11, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Update: [AAIsDead] for CtxI '  store i32 %0, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead-store

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 %0, ptr %a, align 4 (only exact: 0)
Visit underlying object   %a = alloca i32, align 4
[Attributor] Update: [AANoCapture] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state assumed not-captured

[Attributor] Update unchanged [AANoCapture] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state assumed not-captured

[AA] Object '  %a = alloca i32, align 4' is  thread local; non-captured stack object.
[Attributor] Update: [AANoRecurse] for CtxI '  %val.addr = alloca i32, align 4' at position {fn:foo [foo@-1]} with state norecurse

[Attributor] Function foo has no internal linkage, hence not all call sites are known
[Attributor] Update: [AAInterFnReachability] for CtxI '  %val.addr = alloca i32, align 4' at position {fn:foo [foo@-1]} with state #queries(0)

[Attributor] Update unchanged [AAInterFnReachability] for CtxI '  %val.addr = alloca i32, align 4' at position {fn:foo [foo@-1]} with state #queries(0)

[Attributor] Update: [AAIntraFnReachability] for CtxI '  %val.addr = alloca i32, align 4' at position {fn:foo [foo@-1]} with state #queries(0)

[Attributor] Update unchanged [AAIntraFnReachability] for CtxI '  %val.addr = alloca i32, align 4' at position {fn:foo [foo@-1]} with state #queries(0)

[Attributor] Update: [AACallEdges] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %add6)' at position {cs:call [call@-1]} with state CallEdges[0,0]

[AACallEdges] New call edge: printf
[Attributor] Update changed [AACallEdges] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %add6)' at position {cs:call [call@-1]} with state CallEdges[0,1]

[Attributor] Update: [AACallEdges] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %add6)' at position {cs:call [call@-1]} with state CallEdges[0,1]

[Attributor] Update unchanged [AACallEdges] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %add6)' at position {cs:call [call@-1]} with state CallEdges[0,1]

[Attributor] Update changed [AANoRecurse] for CtxI '  %val.addr = alloca i32, align 4' at position {fn:foo [foo@-1]} with state may-recurse

[AA] check   %1 = load i32, ptr %a, align 4 from   store i32 %0, ptr %a, align 4 intraprocedurally
[AA]   store i32 %0, ptr %a, align 4 can potentially reach   %1 = load i32, ptr %a, align 4 [Intra]
[AA] check   %2 = load i32, ptr %a, align 4 from   store i32 %0, ptr %a, align 4 intraprocedurally
[AA]   store i32 %0, ptr %a, align 4 cannot reach   %2 = load i32, ptr %a, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %2 = load i32, ptr %a, align 4 [ToFn]
[AA][Ret]   store i32 %0, ptr %a, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AAIsDead] Store has 1 potential copies.
[Attributor] Update: [AAIsDead] for CtxI '  %1 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Update unchanged [AAIsDead] for CtxI '  %1 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Update unchanged [AAIsDead] for CtxI '  store i32 %0, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead-store

[AAMemoryLocation] Categorize accessed locations for   store i32 %0, ptr %a, align 4
[AAMemoryLocation] Categorize memory access with pointer:   store i32 %0, ptr %a, align 4 [  %a = alloca i32, align 4]
[AAMemoryLocation] Categorize pointer locations for   %a = alloca i32, align 4 [no memory]
[AAMemoryLocation] Ptr value can be categorized:   %a = alloca i32, align 4 -> memory:constant,internal global,external global,argument,inaccessible,malloced,unknown
[AAMemoryLocation] Accessed locations with pointer locations: memory:stack
[AAMemoryLocation] Accessed locations for   store i32 %0, ptr %a, align 4: memory:stack
[Attributor] Update: [AAIsDead] for CtxI '  store i32 %add, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead-store

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 %add, ptr %a, align 4 (only exact: 0)
Visit underlying object   %a = alloca i32, align 4
[AA] Object '  %a = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %1 = load i32, ptr %a, align 4 from   store i32 %add, ptr %a, align 4 intraprocedurally
[AA]   store i32 %add, ptr %a, align 4 cannot reach   %1 = load i32, ptr %a, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %1 = load i32, ptr %a, align 4 [ToFn]
[AA][Ret]   store i32 %add, ptr %a, align 4 can potentially reach   ret void [Intra]
[AA] check @foo from   store i32 %add, ptr %a, align 4 is not checked backwards, abort
[AA] check   %2 = load i32, ptr %a, align 4 from   store i32 %add, ptr %a, align 4 intraprocedurally
[AA]   store i32 %add, ptr %a, align 4 can potentially reach   %2 = load i32, ptr %a, align 4 [Intra]
[AAIsDead] Store has 2 potential copies.
[Attributor] Update: [AAIsDead] for CtxI '  %2 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Update unchanged [AAIsDead] for CtxI '  %2 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Update unchanged [AAIsDead] for CtxI '  store i32 %add, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead-store

[AAMemoryLocation] Categorize accessed locations for   store i32 %add, ptr %a, align 4
[AAMemoryLocation] Categorize memory access with pointer:   store i32 %add, ptr %a, align 4 [  %a = alloca i32, align 4]
[AAMemoryLocation] Categorize pointer locations for   %a = alloca i32, align 4 [no memory]
[AAMemoryLocation] Ptr value can be categorized:   %a = alloca i32, align 4 -> memory:constant,internal global,external global,argument,inaccessible,malloced,unknown
[AAMemoryLocation] Accessed locations with pointer locations: memory:stack
[AAMemoryLocation] Accessed locations for   store i32 %add, ptr %a, align 4: memory:stack
[Attributor] Update: [AAIsDead] for CtxI '  store i32 %2, ptr %field12, align 4' at position {flt: [@-1]} with state assumed-dead-store

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 %2, ptr %field12, align 4 (only exact: 0)
[Attributor] Update: [AAUnderlyingObjects] for CtxI '  %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field12 [field12@-1]} with state UnderlyingObjects inter #0 objs, intra #0 objs

[Attributor] Update: [AAPotentialValues] for CtxI '  %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field12 [field12@-1]} with state set-state(< {} >)

The instruction encountered was:   %f = alloca i32, align 4!
The instruction Opcode was: 31!
Was able to create AAPointer Info object [AAPointerInfo] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

[handleAllocaInst] The first offset is the start of the Alloca.
[handleAllocaInst] Offset size cannot be reduced in Alloca.
[Attributor] Update changed [AAPotentialValues] for CtxI '  %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field12 [field12@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

[Attributor] Update changed [AAUnderlyingObjects] for CtxI '  %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field12 [field12@-1]} with state UnderlyingObjects inter #1 objs, intra #1 objs

Visit underlying object   %f = alloca i32, align 4
[AA] Object '  %f = alloca i32, align 4' is  thread local; non-captured stack object.
[AAIsDead] Store has 0 potential copies.
[Attributor] Update unchanged [AAIsDead] for CtxI '  store i32 %2, ptr %field12, align 4' at position {flt: [@-1]} with state assumed-dead-store

[AAMemoryLocation] Categorize accessed locations for   store i32 %2, ptr %field12, align 4
[AAMemoryLocation] Categorize memory access with pointer:   store i32 %2, ptr %field12, align 4 [  %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0]
[AAMemoryLocation] Categorize pointer locations for   %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 [no memory]
[AAMemoryLocation] Ptr value can be categorized:   %f = alloca i32, align 4 -> memory:constant,internal global,external global,argument,inaccessible,malloced,unknown
[AAMemoryLocation] Accessed locations with pointer locations: memory:stack
[AAMemoryLocation] Accessed locations for   store i32 %2, ptr %field12, align 4: memory:stack
[Attributor] Update: [AAIsDead] for CtxI '  %3 = load i32, ptr %field13, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Update: [AAPotentialValues] for CtxI '  %3 = load i32, ptr %field13, align 4' at position {flt: [@-1]} with state set-state(< {} >)

getPotentiallyLoadedValues!
Trying to determine the potential copies of   %3 = load i32, ptr %field13, align 4 (only exact: 1)
[Attributor] Update: [AAUnderlyingObjects] for CtxI '  %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field13 [field13@-1]} with state UnderlyingObjects inter #0 objs, intra #0 objs

[Attributor] Update: [AAPotentialValues] for CtxI '  %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field13 [field13@-1]} with state set-state(< {} >)

The instruction encountered was:   %f = alloca i32, align 4!
The instruction Opcode was: 31!
Was able to create AAPointer Info object [AAPointerInfo] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

[handleAllocaInst] The first offset is the start of the Alloca.
[handleAllocaInst] Offset size cannot be reduced in Alloca.
[Attributor] Update changed [AAPotentialValues] for CtxI '  %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field13 [field13@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

[Attributor] Update changed [AAUnderlyingObjects] for CtxI '  %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field13 [field13@-1]} with state UnderlyingObjects inter #1 objs, intra #1 objs

Visit underlying object   %f = alloca i32, align 4
[AA] Object '  %f = alloca i32, align 4' is  thread local; non-captured stack object.
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %3 = load i32, ptr %field13, align 4' at position {flt: [@-1]} with state set-state(< {} >)

[Attributor] Update unchanged [AAIsDead] for CtxI '  %3 = load i32, ptr %field13, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Update: [AAIsDead] for CtxI '  store i32 %add4, ptr %field13, align 4' at position {flt: [@-1]} with state assumed-dead-store

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 %add4, ptr %field13, align 4 (only exact: 0)
Visit underlying object   %f = alloca i32, align 4
[AA] Object '  %f = alloca i32, align 4' is  thread local; non-captured stack object.
[AAIsDead] Store has 0 potential copies.
[Attributor] Update unchanged [AAIsDead] for CtxI '  store i32 %add4, ptr %field13, align 4' at position {flt: [@-1]} with state assumed-dead-store

[AAMemoryLocation] Categorize accessed locations for   store i32 %add4, ptr %field13, align 4
[AAMemoryLocation] Categorize memory access with pointer:   store i32 %add4, ptr %field13, align 4 [  %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0]
[AAMemoryLocation] Categorize pointer locations for   %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 [no memory]
[AAMemoryLocation] Ptr value can be categorized:   %f = alloca i32, align 4 -> memory:constant,internal global,external global,argument,inaccessible,malloced,unknown
[AAMemoryLocation] Accessed locations with pointer locations: memory:stack
[AAMemoryLocation] Accessed locations for   store i32 %add4, ptr %field13, align 4: memory:stack
[Attributor] Update: [AAIsDead] for CtxI '  %4 = load i32, ptr %field15, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Update: [AAPotentialValues] for CtxI '  %4 = load i32, ptr %field15, align 4' at position {flt: [@-1]} with state set-state(< {} >)

getPotentiallyLoadedValues!
Trying to determine the potential copies of   %4 = load i32, ptr %field15, align 4 (only exact: 1)
[Attributor] Update: [AAUnderlyingObjects] for CtxI '  %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field15 [field15@-1]} with state UnderlyingObjects inter #0 objs, intra #0 objs

[Attributor] Update: [AAPotentialValues] for CtxI '  %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field15 [field15@-1]} with state set-state(< {} >)

The instruction encountered was:   %f = alloca i32, align 4!
The instruction Opcode was: 31!
Was able to create AAPointer Info object [AAPointerInfo] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

[handleAllocaInst] The first offset is the start of the Alloca.
[handleAllocaInst] Offset size cannot be reduced in Alloca.
[Attributor] Update changed [AAPotentialValues] for CtxI '  %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field15 [field15@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

[Attributor] Update changed [AAUnderlyingObjects] for CtxI '  %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field15 [field15@-1]} with state UnderlyingObjects inter #1 objs, intra #1 objs

Visit underlying object   %f = alloca i32, align 4
[AA] Object '  %f = alloca i32, align 4' is  thread local; non-captured stack object.
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %4 = load i32, ptr %field15, align 4' at position {flt: [@-1]} with state set-state(< {} >)

[Attributor] Update unchanged [AAIsDead] for CtxI '  %4 = load i32, ptr %field15, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Update: [AAIsDead] for CtxI '  %5 = load i32, ptr %val.addr, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Update: [AAPotentialValues] for CtxI '  %5 = load i32, ptr %val.addr, align 4' at position {flt: [@-1]} with state set-state(< {} >)

getPotentiallyLoadedValues!
Trying to determine the potential copies of   %5 = load i32, ptr %val.addr, align 4 (only exact: 1)
Visit underlying object   %val.addr = alloca i32, align 4
[AA] Object '  %val.addr = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %5 = load i32, ptr %val.addr, align 4 from   store i32 %val, ptr %val.addr, align 4 intraprocedurally
[AA]   store i32 %val, ptr %val.addr, align 4 can potentially reach   %5 = load i32, ptr %val.addr, align 4 [Intra]
[Attributor] Update: [AAInstanceInfo] for CtxI '  %val.addr = alloca i32, align 4' at position {arg:val [val@0]} with state <unique [fAa]>

[Attributor] Update unchanged [AAInstanceInfo] for CtxI '  %val.addr = alloca i32, align 4' at position {arg:val [val@0]} with state <unique [fAa]>

[Attributor] Update: [AAValueConstantRange] for CtxI '  %val.addr = alloca i32, align 4' at position {arg:val [val@0]} with state range(32)<full-set / empty-set>

[Attributor] Clamp call site argument states for [AAValueConstantRange] for CtxI '  %val.addr = alloca i32, align 4' at position {arg:val [val@0]} with state range(32)<full-set / empty-set>
 into range-state(32)<full-set / empty-set>
[Attributor] Function foo has no internal linkage, hence not all call sites are known
[Attributor] Update changed [AAValueConstantRange] for CtxI '  %val.addr = alloca i32, align 4' at position {arg:val [val@0]} with state range(32)<full-set / full-set>

[Attributor] Update: [AAPotentialConstantValues] for CtxI '  %val.addr = alloca i32, align 4' at position {arg:val [val@0]} with state set-state(< {} >)

[Attributor] Clamp call site argument states for [AAPotentialConstantValues] for CtxI '  %val.addr = alloca i32, align 4' at position {arg:val [val@0]} with state set-state(< {} >)
 into set-state(< {} >)
[Attributor] Function foo has no internal linkage, hence not all call sites are known
[Attributor] Update changed [AAPotentialConstantValues] for CtxI '  %val.addr = alloca i32, align 4' at position {arg:val [val@0]} with state set-state(< {full-set} >)

[Attributor] Update changed [AAPotentialValues] for CtxI '  %5 = load i32, ptr %val.addr, align 4' at position {flt: [@-1]} with state set-state(< {i32 %val[3], } >)

[Attributor] Got 1 initial uses to check
[Attributor] Update: [AAIsDead] for CtxI '  %add6 = add nsw i32 %4, %5' at position {flt:add6 [add6@-1]} with state assumed-dead

[Attributor] Update: [AAPotentialValues] for CtxI '  %add6 = add nsw i32 %4, %5' at position {flt:add6 [add6@-1]} with state set-state(< {} >)

[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %add6 = add nsw i32 %4, %5' at position {flt:add6 [add6@-1]} with state set-state(< {} >)

[Attributor] Update unchanged [AAIsDead] for CtxI '  %add6 = add nsw i32 %4, %5' at position {flt:add6 [add6@-1]} with state assumed-dead

[Attributor] Update unchanged [AAIsDead] for CtxI '  %5 = load i32, ptr %val.addr, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Update: [AANoUnwind] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %add6)' at position {cs:call [call@-1]} with state nounwind

[Attributor] Update changed [AANoUnwind] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %add6)' at position {cs:call [call@-1]} with state may-unwind

[AAMemoryLocation] Categorize accessed locations for   %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %add6)
[Attributor] Update: [AAMemoryLocation] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %add6)' at position {cs:call [call@-1]} with state memory

[Attributor] Update changed [AAMemoryLocation] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %add6)' at position {cs:call [call@-1]} with state all memory

[AAMemoryLocation] Categorize call site:   %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %add6) [0x55b373417de0]
[AAMemoryLocation] Accessed locations for   %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %add6): all memory
[Attributor] Update changed [AAMemoryLocation] for CtxI '  %val.addr = alloca i32, align 4' at position {fn:foo [foo@-1]} with state all memory

[Attributor] Got 5 initial uses to check
[Attributor] Update: [AAIsDead] for CtxI '  %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field1 [field1@-1]} with state assumed-dead

[Attributor] Got 1 initial uses to check
[Attributor] Update changed [AAIsDead] for CtxI '  %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field1 [field1@-1]} with state assumed-live

[Attributor] Update: [AAIsDead] for CtxI '  %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field11 [field11@-1]} with state assumed-dead

[Attributor] Update unchanged [AAIsDead] for CtxI '  %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field11 [field11@-1]} with state assumed-dead

[Attributor] Update: [AAIsDead] for CtxI '  %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field12 [field12@-1]} with state assumed-dead

[Attributor] Got 1 initial uses to check
[Attributor] Update changed [AAIsDead] for CtxI '  %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field12 [field12@-1]} with state assumed-live

[Attributor] Update: [AAIsDead] for CtxI '  %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field13 [field13@-1]} with state assumed-dead

[Attributor] Got 2 initial uses to check
[Attributor] Update changed [AAIsDead] for CtxI '  %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field13 [field13@-1]} with state assumed-live

[Attributor] Update: [AAIsDead] for CtxI '  %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field15 [field15@-1]} with state assumed-dead

[Attributor] Got 1 initial uses to check
[Attributor] Update unchanged [AAIsDead] for CtxI '  %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field15 [field15@-1]} with state assumed-dead

[Attributor] Update unchanged [AANoCapture] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state assumed not-captured

[AA] Object '  %f = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %0 = load i32, ptr %field11, align 4 from   store i32 10, ptr %field1, align 4 intraprocedurally
[AA]   store i32 10, ptr %field1, align 4 can potentially reach   %0 = load i32, ptr %field11, align 4 [Intra]
[AAIsDead] Store has 1 potential copies.
[Attributor] Update unchanged [AAIsDead] for CtxI '  store i32 10, ptr %field1, align 4' at position {flt: [@-1]} with state assumed-dead-store

[Attributor] Update: [AAMemoryBehavior] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %add6)' at position {cs:call [call@-1]} with state readnone

[Attributor] Update changed [AAMemoryBehavior] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %add6)' at position {cs:call [call@-1]} with state may-read/write

[Attributor] Update changed [AAMemoryBehavior] for CtxI '  %val.addr = alloca i32, align 4' at position {fn:foo [foo@-1]} with state may-read/write

[Attributor] Got 2 initial uses to check
[Attributor] Update unchanged [AANoCapture] for CtxI '  %val.addr = alloca i32, align 4' at position {flt:val.addr [val.addr@-1]} with state assumed not-captured

[AA] Object '  %val.addr = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %5 = load i32, ptr %val.addr, align 4 from   store i32 %val, ptr %val.addr, align 4 intraprocedurally
[AA]   store i32 %val, ptr %val.addr, align 4 can potentially reach   %5 = load i32, ptr %val.addr, align 4 [Intra]
[AAIsDead] Store has 1 potential copies.
[Attributor] Update unchanged [AAIsDead] for CtxI '  store i32 %val, ptr %val.addr, align 4' at position {flt: [@-1]} with state assumed-dead-store

[Attributor] Update: [AANoSync] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %add6)' at position {cs:call [call@-1]} with state nosync

[Attributor] Update changed [AANoSync] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %add6)' at position {cs:call [call@-1]} with state may-sync

[Attributor] Update changed [AANoSync] for CtxI '  %val.addr = alloca i32, align 4' at position {fn:foo [foo@-1]} with state may-sync

[AA] Object '  %a = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %2 = load i32, ptr %a, align 4 from   store i32 %0, ptr %a, align 4 intraprocedurally
[AA]   store i32 %0, ptr %a, align 4 cannot reach   %2 = load i32, ptr %a, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %2 = load i32, ptr %a, align 4 [ToFn]
[AA][Ret]   store i32 %0, ptr %a, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AA] check   %2 = load i32, ptr %a, align 4 from   store i32 %add, ptr %a, align 4 intraprocedurally
[AA]   store i32 %add, ptr %a, align 4 can potentially reach   %2 = load i32, ptr %a, align 4 [Intra]
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %2 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state set-state(< {} >)

[AAPointerInfo] Inserting access in new offset bins
    key [0, 4]
[AAPointerInfo] Analyze   %f = alloca i32, align 4 in   %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] GEP offset is  constant   %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] Analyze   %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   %3 = load i32, ptr %field13, align 4
[AAPointerInfo] Inserting access in new offset bins
    key [0, 4]
[AAPointerInfo] Analyze   %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   store i32 %add4, ptr %field13, align 4
[Attributor] Update: [AAPotentialValues] for CtxI '  %add4 = add nsw i32 %3, 1' at position {flt:add4 [add4@-1]} with state set-state(< {} >)

[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %add4 = add nsw i32 %3, 1' at position {flt:add4 [add4@-1]} with state set-state(< {} >)

[AAPointerInfo] Inserting access in new offset bins
    key [0, 4]
[AAPointerInfo] Analyze   %f = alloca i32, align 4 in   %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] GEP offset is  constant   %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] Analyze   %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   %4 = load i32, ptr %field15, align 4
[AAPointerInfo] Inserting access in new offset bins
    key [0, 4]
Accesses by bin after update:
[0-4] : 6
     - 9 -   store i32 10, ptr %field1, align 4
       - c: i32 10
     - 5 -   %0 = load i32, ptr %field11, align 4
       - c: <unknown>
     - 9 -   store i32 %2, ptr %field12, align 4
     - 5 -   %3 = load i32, ptr %field13, align 4
       - c: <unknown>
     - 9 -   store i32 %add4, ptr %field13, align 4
     - 5 -   %4 = load i32, ptr %field15, align 4
       - c: <unknown>
[Attributor] Update changed [AAPointerInfo] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

Was able to create AAPointer Info object [AAPointerInfo] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

[handleAllocaInst] The first offset is the start of the Alloca.
[handleAllocaInst] Offset size cannot be reduced in Alloca.
[Attributor] Update changed [AAPotentialValues] for CtxI '  %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field11 [field11@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

[Attributor] Update changed [AAUndefinedBehavior] for CtxI '  %val.addr = alloca i32, align 4' at position {fn:foo [foo@-1]} with state undefined-behavior

[Attributor] Update: [AAHeapToStack] for CtxI '  %val.addr = alloca i32, align 4' at position {fn:foo [foo@-1]} with state [H2S] Mallocs Good/Bad: 0/0

[Attributor] Update unchanged [AAHeapToStack] for CtxI '  %val.addr = alloca i32, align 4' at position {fn:foo [foo@-1]} with state [H2S] Mallocs Good/Bad: 0/0

[Attributor] Update: [AAWillReturn] for CtxI '  %val.addr = alloca i32, align 4' at position {fn:foo [foo@-1]} with state willreturn

[Attributor] Update: [AAWillReturn] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %add6)' at position {cs:call [call@-1]} with state willreturn

[Attributor] Update changed [AAWillReturn] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %add6)' at position {cs:call [call@-1]} with state may-noreturn

[Attributor] Update changed [AAWillReturn] for CtxI '  %val.addr = alloca i32, align 4' at position {fn:foo [foo@-1]} with state may-noreturn

[Attributor] Update: [AAMustProgress] for CtxI '  %val.addr = alloca i32, align 4' at position {fn:foo [foo@-1]} with state mustprogress

[Attributor] Function foo has no internal linkage, hence not all call sites are known
[Attributor] Update changed [AAMustProgress] for CtxI '  %val.addr = alloca i32, align 4' at position {fn:foo [foo@-1]} with state may-not-progress

[Attributor] Update: [AANoFree] for CtxI '  %val.addr = alloca i32, align 4' at position {fn:foo [foo@-1]} with state nofree

[Attributor] Update: [AANoFree] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %add6)' at position {cs:call [call@-1]} with state nofree

[Attributor] Update changed [AANoFree] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %add6)' at position {cs:call [call@-1]} with state may-free

[Attributor] Update changed [AANoFree] for CtxI '  %val.addr = alloca i32, align 4' at position {fn:foo [foo@-1]} with state may-free

[Attributor] Update: [AANoReturn] for CtxI '  %val.addr = alloca i32, align 4' at position {fn:foo [foo@-1]} with state noreturn

[Attributor] Update changed [AANoReturn] for CtxI '  %val.addr = alloca i32, align 4' at position {fn:foo [foo@-1]} with state may-return

[Attributor] Update: [AAAssumptionInfo] for CtxI '  %val.addr = alloca i32, align 4' at position {fn:foo [foo@-1]} with state Known [], Assumed [Universal]

[Attributor] Function foo has no internal linkage, hence not all call sites are known
[Attributor] Update changed [AAAssumptionInfo] for CtxI '  %val.addr = alloca i32, align 4' at position {fn:foo [foo@-1]} with state Known [], Assumed []

[Attributor] Update: [AAIsDead] for CtxI '  %val.addr = alloca i32, align 4' at position {arg:val [val@0]} with state assumed-dead

[Attributor] Got 1 initial uses to check
[Attributor] Update unchanged [AAIsDead] for CtxI '  %val.addr = alloca i32, align 4' at position {arg:val [val@0]} with state assumed-dead

[Attributor] Update: [AAAssumptionInfo] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %add6)' at position {cs:call [call@-1]} with state Known [], Assumed [Universal]

[Attributor] Update changed [AAAssumptionInfo] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %add6)' at position {cs:call [call@-1]} with state Known [], Assumed []

[Attributor] Update: [AAAssumptionInfo] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %add6)' at position {cs:call [call@-1]} with state Known [], Assumed []

[Attributor] Update unchanged [AAAssumptionInfo] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %add6)' at position {cs:call [call@-1]} with state Known [], Assumed []

[Attributor] Update: [AAAlign] for CtxI '  %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field11 [field11@-1]} with state align<4-4294967296>

[Attributor] Update: [AAAlign] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state align<4-4294967296>

[Attributor] Update changed [AAAlign] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state align<4-4>

[Attributor] Update changed [AAAlign] for CtxI '  %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field11 [field11@-1]} with state align<4-4>

[Attributor] Update: [AAAlign] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state align<4-4294967296>

[Attributor] Update changed [AAAlign] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state align<4-4>

[Attributor] Update: [AAAlign] for CtxI '  %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field13 [field13@-1]} with state align<4-4294967296>

[Attributor] Update changed [AAAlign] for CtxI '  %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field13 [field13@-1]} with state align<4-4>

[Attributor] Update: [AAAlign] for CtxI '  %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field15 [field15@-1]} with state align<4-4294967296>

[Attributor] Update changed [AAAlign] for CtxI '  %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field15 [field15@-1]} with state align<4-4>

[Attributor] Update: [AAAlign] for CtxI '  %val.addr = alloca i32, align 4' at position {flt:val.addr [val.addr@-1]} with state align<4-4294967296>

[Attributor] Update changed [AAAlign] for CtxI '  %val.addr = alloca i32, align 4' at position {flt:val.addr [val.addr@-1]} with state align<4-4>

[Attributor] Update: [AAAlign] for CtxI '  %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field1 [field1@-1]} with state align<4-4294967296>

[Attributor] Update changed [AAAlign] for CtxI '  %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field1 [field1@-1]} with state align<4-4>

[Attributor] Update: [AAAlign] for CtxI '  %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field12 [field12@-1]} with state align<4-4294967296>

[Attributor] Update changed [AAAlign] for CtxI '  %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field12 [field12@-1]} with state align<4-4>

[Attributor] Update: [AAIsDead] for CtxI '  call void @foo(i32 noundef 10)' at position {fn:main [main@-1]} with state Live[#BB 1/1][#TBEP 1][#KDE 0]

[AAIsDead] Live [1/1] BBs and 1 exploration points and 0 known dead ends
[AAIsDead] Exploration inst:   call void @foo(i32 noundef 10)
[AAIsDead] #AliveSuccessors: 1 UsedAssumedInformation: 0
[AAIsDead] Exploration inst:   ret i32 0
[AAIsDead] #AliveSuccessors: 0 UsedAssumedInformation: 0
[Attributor] Update changed [AAIsDead] for CtxI '  call void @foo(i32 noundef 10)' at position {fn:main [main@-1]} with state Live[#BB 1/1][#TBEP 0][#KDE 1]

[Attributor] Update: [AAUndefinedBehavior] for CtxI '  call void @foo(i32 noundef 10)' at position {fn:main [main@-1]} with state undefined-behavior

[Attributor] Update: [AAMemoryBehavior] for CtxI '  call void @foo(i32 noundef 10)' at position {cs: [@-1]} with state readnone

[Attributor] Update changed [AAMemoryBehavior] for CtxI '  call void @foo(i32 noundef 10)' at position {cs: [@-1]} with state may-read/write

[Attributor] Update: [AAMemoryLocation] for CtxI '  call void @foo(i32 noundef 10)' at position {cs: [@-1]} with state memory

[Attributor] Update changed [AAMemoryLocation] for CtxI '  call void @foo(i32 noundef 10)' at position {cs: [@-1]} with state all memory

[Attributor] Update: [AAIsDead] for CtxI '  call void @foo(i32 noundef 10)' at position {fn_ret:main [main@-1]} with state assumed-dead

[Attributor] Function main has no internal linkage, hence not all call sites are known
[Attributor] Update changed [AAIsDead] for CtxI '  call void @foo(i32 noundef 10)' at position {fn_ret:main [main@-1]} with state assumed-live

[Attributor] Update: [AANoUndef] for CtxI '  call void @foo(i32 noundef 10)' at position {fn_ret:main [main@-1]} with state noundef

[Attributor] Clamp return value states for [AANoUndef] for CtxI '  call void @foo(i32 noundef 10)' at position {fn_ret:main [main@-1]} with state noundef
 into (0-1)
[Attributor] Update: [AAReturnedValues] for CtxI '  call void @foo(i32 noundef 10)' at position {fn:main [main@-1]} with state may-return(#0)

[Attributor] Update changed [AAReturnedValues] for CtxI '  call void @foo(i32 noundef 10)' at position {fn:main [main@-1]} with state may-return(#1)

[Attributor] Update: [AAReturnedValues] for CtxI '  call void @foo(i32 noundef 10)' at position {fn:main [main@-1]} with state may-return(#1)

[Attributor] Update unchanged [AAReturnedValues] for CtxI '  call void @foo(i32 noundef 10)' at position {fn:main [main@-1]} with state may-return(#1)

[Attributor] RV: i32 0 AA: noundef @ {flt: [@-1]}
[Attributor] AA State: (1-1)fix RV State: (0-1)
[Attributor] Update unchanged [AANoUndef] for CtxI '  call void @foo(i32 noundef 10)' at position {fn_ret:main [main@-1]} with state noundef

[Attributor] Update unchanged [AAUndefinedBehavior] for CtxI '  call void @foo(i32 noundef 10)' at position {fn:main [main@-1]} with state undefined-behavior

[Attributor] Update: [AAHeapToStack] for CtxI '  call void @foo(i32 noundef 10)' at position {fn:main [main@-1]} with state [H2S] Mallocs Good/Bad: 0/0

[Attributor] Update unchanged [AAHeapToStack] for CtxI '  call void @foo(i32 noundef 10)' at position {fn:main [main@-1]} with state [H2S] Mallocs Good/Bad: 0/0

[Attributor] Update: [AAWillReturn] for CtxI '  call void @foo(i32 noundef 10)' at position {fn:main [main@-1]} with state willreturn

[Attributor] Update: [AAWillReturn] for CtxI '  call void @foo(i32 noundef 10)' at position {cs: [@-1]} with state willreturn

[Attributor] Update changed [AAWillReturn] for CtxI '  call void @foo(i32 noundef 10)' at position {cs: [@-1]} with state may-noreturn

[Attributor] Update changed [AAWillReturn] for CtxI '  call void @foo(i32 noundef 10)' at position {fn:main [main@-1]} with state may-noreturn

[Attributor] Update: [AAMustProgress] for CtxI '  call void @foo(i32 noundef 10)' at position {fn:main [main@-1]} with state mustprogress

[Attributor] Function main has no internal linkage, hence not all call sites are known
[Attributor] Update changed [AAMustProgress] for CtxI '  call void @foo(i32 noundef 10)' at position {fn:main [main@-1]} with state may-not-progress

[Attributor] Update: [AANoSync] for CtxI '  call void @foo(i32 noundef 10)' at position {fn:main [main@-1]} with state nosync

[Attributor] Update: [AANoSync] for CtxI '  call void @foo(i32 noundef 10)' at position {cs: [@-1]} with state nosync

[Attributor] Update changed [AANoSync] for CtxI '  call void @foo(i32 noundef 10)' at position {cs: [@-1]} with state may-sync

[Attributor] Update changed [AANoSync] for CtxI '  call void @foo(i32 noundef 10)' at position {fn:main [main@-1]} with state may-sync

[Attributor] Update: [AANoFree] for CtxI '  call void @foo(i32 noundef 10)' at position {fn:main [main@-1]} with state nofree

[Attributor] Update: [AANoFree] for CtxI '  call void @foo(i32 noundef 10)' at position {cs: [@-1]} with state nofree

[Attributor] Update changed [AANoFree] for CtxI '  call void @foo(i32 noundef 10)' at position {cs: [@-1]} with state may-free

[Attributor] Update changed [AANoFree] for CtxI '  call void @foo(i32 noundef 10)' at position {fn:main [main@-1]} with state may-free

[Attributor] Update: [AANoReturn] for CtxI '  call void @foo(i32 noundef 10)' at position {fn:main [main@-1]} with state noreturn

[Attributor] Update changed [AANoReturn] for CtxI '  call void @foo(i32 noundef 10)' at position {fn:main [main@-1]} with state may-return

[Attributor] Update: [AANoRecurse] for CtxI '  call void @foo(i32 noundef 10)' at position {fn:main [main@-1]} with state norecurse

[Attributor] Function main has no internal linkage, hence not all call sites are known
[Attributor] Update: [AAInterFnReachability] for CtxI '  call void @foo(i32 noundef 10)' at position {fn:main [main@-1]} with state #queries(0)

[Attributor] Update unchanged [AAInterFnReachability] for CtxI '  call void @foo(i32 noundef 10)' at position {fn:main [main@-1]} with state #queries(0)

[Attributor] Update: [AAIntraFnReachability] for CtxI '  call void @foo(i32 noundef 10)' at position {fn:main [main@-1]} with state #queries(0)

[Attributor] Update unchanged [AAIntraFnReachability] for CtxI '  call void @foo(i32 noundef 10)' at position {fn:main [main@-1]} with state #queries(0)

[Attributor] Update: [AACallEdges] for CtxI '  call void @foo(i32 noundef 10)' at position {cs: [@-1]} with state CallEdges[0,0]

[AACallEdges] New call edge: foo
[Attributor] Update changed [AACallEdges] for CtxI '  call void @foo(i32 noundef 10)' at position {cs: [@-1]} with state CallEdges[0,1]

[Attributor] Update: [AACallEdges] for CtxI '  call void @foo(i32 noundef 10)' at position {cs: [@-1]} with state CallEdges[0,1]

[Attributor] Update unchanged [AACallEdges] for CtxI '  call void @foo(i32 noundef 10)' at position {cs: [@-1]} with state CallEdges[0,1]

[Attributor] Update changed [AANoRecurse] for CtxI '  call void @foo(i32 noundef 10)' at position {fn:main [main@-1]} with state may-recurse

[Attributor] Update: [AAMemoryBehavior] for CtxI '  call void @foo(i32 noundef 10)' at position {fn:main [main@-1]} with state readnone

[Attributor] Update changed [AAMemoryBehavior] for CtxI '  call void @foo(i32 noundef 10)' at position {fn:main [main@-1]} with state may-read/write

[Attributor] Update: [AAMemoryLocation] for CtxI '  call void @foo(i32 noundef 10)' at position {fn:main [main@-1]} with state memory

[AAMemoryLocation] Categorize accessed locations for   call void @foo(i32 noundef 10)
[AAMemoryLocation] Categorize call site:   call void @foo(i32 noundef 10) [0x55b37344ed10]
[AAMemoryLocation] Accessed locations for   call void @foo(i32 noundef 10): all memory
[Attributor] Update changed [AAMemoryLocation] for CtxI '  call void @foo(i32 noundef 10)' at position {fn:main [main@-1]} with state all memory

[Attributor] Update: [AAAssumptionInfo] for CtxI '  call void @foo(i32 noundef 10)' at position {fn:main [main@-1]} with state Known [], Assumed [Universal]

[Attributor] Function main has no internal linkage, hence not all call sites are known
[Attributor] Update changed [AAAssumptionInfo] for CtxI '  call void @foo(i32 noundef 10)' at position {fn:main [main@-1]} with state Known [], Assumed []

[Attributor] Update: [AAPotentialValues] for CtxI '  call void @foo(i32 noundef 10)' at position {fn_ret:main [main@-1]} with state set-state(< {} >)

[Attributor] Clamp return value states for [AAPotentialValues] for CtxI '  call void @foo(i32 noundef 10)' at position {fn_ret:main [main@-1]} with state set-state(< {} >)
 into set-state(< {} >)
[Attributor] RV: i32 0 AA: set-state(< {i32 0[3], } >) @ {flt: [@-1]}
[Attributor] AA State: set-state(< {i32 0[3], } >) RV State: set-state(< {i32 0[3], } >)
[Attributor] Update changed [AAPotentialValues] for CtxI '  call void @foo(i32 noundef 10)' at position {fn_ret:main [main@-1]} with state set-state(< {i32 0[3], } >)

[Attributor] Update: [AAPotentialValues] for CtxI '  call void @foo(i32 noundef 10)' at position {fn_ret:main [main@-1]} with state set-state(< {i32 0[3], } >)

[Attributor] Clamp return value states for [AAPotentialValues] for CtxI '  call void @foo(i32 noundef 10)' at position {fn_ret:main [main@-1]} with state set-state(< {i32 0[3], } >)
 into set-state(< {} >)
[Attributor] RV: i32 0 AA: set-state(< {i32 0[3], } >) @ {flt: [@-1]}
[Attributor] AA State: set-state(< {i32 0[3], } >) RV State: set-state(< {i32 0[3], } >)
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  call void @foo(i32 noundef 10)' at position {fn_ret:main [main@-1]} with state set-state(< {i32 0[3], } >)

[Attributor] Update: [AAAssumptionInfo] for CtxI '  call void @foo(i32 noundef 10)' at position {cs: [@-1]} with state Known [], Assumed [Universal]

[Attributor] Update changed [AAAssumptionInfo] for CtxI '  call void @foo(i32 noundef 10)' at position {cs: [@-1]} with state Known [], Assumed []

[Attributor] Update: [AAAssumptionInfo] for CtxI '  call void @foo(i32 noundef 10)' at position {cs: [@-1]} with state Known [], Assumed []

[Attributor] Update unchanged [AAAssumptionInfo] for CtxI '  call void @foo(i32 noundef 10)' at position {cs: [@-1]} with state Known [], Assumed []

[Attributor] Update: [AAIsDead] for CtxI '  call void @foo(i32 noundef 10)' at position {cs_arg: [@0]} with state assumed-dead

[Attributor] Update unchanged [AAIsDead] for CtxI '  call void @foo(i32 noundef 10)' at position {cs_arg: [@0]} with state assumed-dead

[Attributor] Identified and initialized 133 abstract attributes.


[Attributor] #Iteration: 1, Worklist size: 133
[Attributor] #Iteration: 1, Worklist+Dependent size: 133
[Attributor] Update: [AAUndefinedBehavior] for CtxI '  %val.addr = alloca i32, align 4' at position {fn:foo [foo@-1]} with state undefined-behavior

[Attributor] Update unchanged [AAUndefinedBehavior] for CtxI '  %val.addr = alloca i32, align 4' at position {fn:foo [foo@-1]} with state undefined-behavior

[Attributor] Update: [AAPotentialValues] for CtxI '  %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field11 [field11@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

The instruction encountered was:   %f = alloca i32, align 4!
The instruction Opcode was: 31!
Was able to create AAPointer Info object [AAPointerInfo] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

[handleAllocaInst] The first offset is the start of the Alloca.
[handleAllocaInst] Offset size cannot be reduced in Alloca.
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field11 [field11@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

[Attributor] Update: [AAPointerInfo] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

[Attributor] Got 5 initial uses to check
[AAPointerInfo] Analyze   %f = alloca i32, align 4 in   %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] GEP offset is  constant   %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] Analyze   %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   store i32 10, ptr %field1, align 4
[AAPointerInfo] Analyze   %f = alloca i32, align 4 in   %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] GEP offset is  constant   %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] Analyze   %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   %0 = load i32, ptr %field11, align 4
[AAPointerInfo] Analyze   %f = alloca i32, align 4 in   %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] GEP offset is  constant   %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] Analyze   %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   store i32 %2, ptr %field12, align 4
[AAPointerInfo] Analyze   %f = alloca i32, align 4 in   %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] GEP offset is  constant   %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] Analyze   %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   %3 = load i32, ptr %field13, align 4
[AAPointerInfo] Analyze   %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   store i32 %add4, ptr %field13, align 4
[AAPointerInfo] Analyze   %f = alloca i32, align 4 in   %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] GEP offset is  constant   %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] Analyze   %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   %4 = load i32, ptr %field15, align 4
Accesses by bin after update:
[0-4] : 6
     - 9 -   store i32 10, ptr %field1, align 4
       - c: i32 10
     - 5 -   %0 = load i32, ptr %field11, align 4
       - c: <unknown>
     - 9 -   store i32 %2, ptr %field12, align 4
     - 5 -   %3 = load i32, ptr %field13, align 4
       - c: <unknown>
     - 9 -   store i32 %add4, ptr %field13, align 4
     - 5 -   %4 = load i32, ptr %field15, align 4
       - c: <unknown>
[Attributor] Update unchanged [AAPointerInfo] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

[Attributor] Update: [AAPotentialValues] for CtxI '  %2 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state set-state(< {} >)

getPotentiallyLoadedValues!
Trying to determine the potential copies of   %2 = load i32, ptr %a, align 4 (only exact: 1)
Visit underlying object   %a = alloca i32, align 4
[AA] Object '  %a = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %2 = load i32, ptr %a, align 4 from   store i32 %0, ptr %a, align 4 intraprocedurally
[AA]   store i32 %0, ptr %a, align 4 cannot reach   %2 = load i32, ptr %a, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %2 = load i32, ptr %a, align 4 [ToFn]
[AA][Ret]   store i32 %0, ptr %a, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AA] check   %2 = load i32, ptr %a, align 4 from   store i32 %add, ptr %a, align 4 intraprocedurally
[AA]   store i32 %add, ptr %a, align 4 can potentially reach   %2 = load i32, ptr %a, align 4 [Intra]
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %2 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state set-state(< {} >)

[Attributor] Update: [AAPointerInfo] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state PointerInfo #1 bins

[Attributor] Got 4 initial uses to check
[AAPointerInfo] Analyze   %a = alloca i32, align 4 in   store i32 %0, ptr %a, align 4
[AAPointerInfo] Analyze   %a = alloca i32, align 4 in   %1 = load i32, ptr %a, align 4
[AAPointerInfo] Analyze   %a = alloca i32, align 4 in   store i32 %add, ptr %a, align 4
[AAPointerInfo] Analyze   %a = alloca i32, align 4 in   %2 = load i32, ptr %a, align 4
Accesses by bin after update:
[0-4] : 4
     - 9 -   store i32 %0, ptr %a, align 4
     - 5 -   %1 = load i32, ptr %a, align 4
       - c: <unknown>
     - 9 -   store i32 %add, ptr %a, align 4
     - 5 -   %2 = load i32, ptr %a, align 4
       - c: <unknown>
[Attributor] Update unchanged [AAPointerInfo] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state PointerInfo #1 bins

[Attributor] Update: [AAPotentialValues] for CtxI '  %0 = load i32, ptr %field11, align 4' at position {flt: [@-1]} with state set-state(< {} >)

getPotentiallyLoadedValues!
Trying to determine the potential copies of   %0 = load i32, ptr %field11, align 4 (only exact: 1)
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %0 = load i32, ptr %field11, align 4' at position {flt: [@-1]} with state set-state(< {} >)

[Attributor] Update: [AAUnderlyingObjects] for CtxI '  %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field11 [field11@-1]} with state UnderlyingObjects inter #0 objs, intra #0 objs

[Attributor] Update changed [AAUnderlyingObjects] for CtxI '  %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field11 [field11@-1]} with state UnderlyingObjects inter #1 objs, intra #1 objs

[Attributor] Update: [AAPotentialValues] for CtxI '  %add = add nsw i32 %1, 1' at position {flt:add [add@-1]} with state set-state(< {} >)

[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %add = add nsw i32 %1, 1' at position {flt:add [add@-1]} with state set-state(< {} >)

[Attributor] Update: [AAPotentialValues] for CtxI '  %1 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state set-state(< {} >)

getPotentiallyLoadedValues!
Trying to determine the potential copies of   %1 = load i32, ptr %a, align 4 (only exact: 1)
Visit underlying object   %a = alloca i32, align 4
[AA] Object '  %a = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %1 = load i32, ptr %a, align 4 from   store i32 %0, ptr %a, align 4 intraprocedurally
[AA]   store i32 %0, ptr %a, align 4 can potentially reach   %1 = load i32, ptr %a, align 4 [Intra]
[AA] check   %1 = load i32, ptr %a, align 4 from   store i32 %add, ptr %a, align 4 intraprocedurally
[AA]   store i32 %add, ptr %a, align 4 cannot reach   %1 = load i32, ptr %a, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %1 = load i32, ptr %a, align 4 [ToFn]
[AA][Ret]   store i32 %add, ptr %a, align 4 can potentially reach   ret void [Intra]
[AA] check @foo from   store i32 %add, ptr %a, align 4 is not checked backwards, abort
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %1 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state set-state(< {} >)

[Attributor] Update: [AAIsDead] for CtxI '  store i32 %val, ptr %val.addr, align 4' at position {flt: [@-1]} with state assumed-dead-store

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 %val, ptr %val.addr, align 4 (only exact: 0)
Visit underlying object   %val.addr = alloca i32, align 4
[AA] Object '  %val.addr = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %5 = load i32, ptr %val.addr, align 4 from   store i32 %val, ptr %val.addr, align 4 intraprocedurally
[AA]   store i32 %val, ptr %val.addr, align 4 can potentially reach   %5 = load i32, ptr %val.addr, align 4 [Intra]
[AAIsDead] Store has 1 potential copies.
[Attributor] Update unchanged [AAIsDead] for CtxI '  store i32 %val, ptr %val.addr, align 4' at position {flt: [@-1]} with state assumed-dead-store

[Attributor] Update: [AANoCapture] for CtxI '  %val.addr = alloca i32, align 4' at position {flt:val.addr [val.addr@-1]} with state assumed not-captured

[Attributor] Got 2 initial uses to check
[Attributor] Update unchanged [AANoCapture] for CtxI '  %val.addr = alloca i32, align 4' at position {flt:val.addr [val.addr@-1]} with state assumed not-captured

[Attributor] Update: [AAIsDead] for CtxI '  store i32 10, ptr %field1, align 4' at position {flt: [@-1]} with state assumed-dead-store

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 10, ptr %field1, align 4 (only exact: 0)
Visit underlying object   %f = alloca i32, align 4
[AA] Object '  %f = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %0 = load i32, ptr %field11, align 4 from   store i32 10, ptr %field1, align 4 intraprocedurally
[AA]   store i32 10, ptr %field1, align 4 can potentially reach   %0 = load i32, ptr %field11, align 4 [Intra]
[AA] check   %3 = load i32, ptr %field13, align 4 from   store i32 10, ptr %field1, align 4 intraprocedurally
[AA]   store i32 10, ptr %field1, align 4 cannot reach   %3 = load i32, ptr %field13, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %3 = load i32, ptr %field13, align 4 [ToFn]
[AA][Ret]   store i32 10, ptr %field1, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AA] check   %4 = load i32, ptr %field15, align 4 from   store i32 10, ptr %field1, align 4 intraprocedurally
[AA]   store i32 10, ptr %field1, align 4 cannot reach   %4 = load i32, ptr %field15, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %4 = load i32, ptr %field15, align 4 [ToFn]
[AA][Ret]   store i32 10, ptr %field1, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AAIsDead] Store has 1 potential copies.
[Attributor] Update unchanged [AAIsDead] for CtxI '  store i32 10, ptr %field1, align 4' at position {flt: [@-1]} with state assumed-dead-store

[Attributor] Update: [AAUnderlyingObjects] for CtxI '  %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field1 [field1@-1]} with state UnderlyingObjects inter #1 objs, intra #1 objs

[Attributor] Update unchanged [AAUnderlyingObjects] for CtxI '  %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field1 [field1@-1]} with state UnderlyingObjects inter #1 objs, intra #1 objs

[Attributor] Update: [AAPotentialValues] for CtxI '  %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field1 [field1@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

The instruction encountered was:   %f = alloca i32, align 4!
The instruction Opcode was: 31!
Was able to create AAPointer Info object [AAPointerInfo] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

[handleAllocaInst] The first offset is the start of the Alloca.
[handleAllocaInst] Offset size cannot be reduced in Alloca.
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field1 [field1@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

[Attributor] Update: [AANoCapture] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state assumed not-captured

[Attributor] Got 5 initial uses to check
[Attributor] Update unchanged [AANoCapture] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state assumed not-captured

[Attributor] Update: [AAIsDead] for CtxI '  %0 = load i32, ptr %field11, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Update unchanged [AAIsDead] for CtxI '  %0 = load i32, ptr %field11, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Update: [AAIsDead] for CtxI '  store i32 %0, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead-store

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 %0, ptr %a, align 4 (only exact: 0)
Visit underlying object   %a = alloca i32, align 4
[AA] Object '  %a = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %1 = load i32, ptr %a, align 4 from   store i32 %0, ptr %a, align 4 intraprocedurally
[AA]   store i32 %0, ptr %a, align 4 can potentially reach   %1 = load i32, ptr %a, align 4 [Intra]
[AA] check   %2 = load i32, ptr %a, align 4 from   store i32 %0, ptr %a, align 4 intraprocedurally
[AA]   store i32 %0, ptr %a, align 4 cannot reach   %2 = load i32, ptr %a, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %2 = load i32, ptr %a, align 4 [ToFn]
[AA][Ret]   store i32 %0, ptr %a, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AAIsDead] Store has 1 potential copies.
[Attributor] Update unchanged [AAIsDead] for CtxI '  store i32 %0, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead-store

[Attributor] Update: [AANoCapture] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state assumed not-captured

[Attributor] Got 4 initial uses to check
[Attributor] Update unchanged [AANoCapture] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state assumed not-captured

[Attributor] Update: [AAInterFnReachability] for CtxI '  %val.addr = alloca i32, align 4' at position {fn:foo [foo@-1]} with state #queries(2)

[Attributor] Update unchanged [AAInterFnReachability] for CtxI '  %val.addr = alloca i32, align 4' at position {fn:foo [foo@-1]} with state #queries(2)

[Attributor] Update: [AAIntraFnReachability] for CtxI '  %val.addr = alloca i32, align 4' at position {fn:foo [foo@-1]} with state #queries(21)

[Attributor] Update unchanged [AAIntraFnReachability] for CtxI '  %val.addr = alloca i32, align 4' at position {fn:foo [foo@-1]} with state #queries(21)

[Attributor] Update: [AAIsDead] for CtxI '  %1 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Update unchanged [AAIsDead] for CtxI '  %1 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Update: [AAIsDead] for CtxI '  store i32 %add, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead-store

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 %add, ptr %a, align 4 (only exact: 0)
Visit underlying object   %a = alloca i32, align 4
[AA] Object '  %a = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %1 = load i32, ptr %a, align 4 from   store i32 %add, ptr %a, align 4 intraprocedurally
[AA]   store i32 %add, ptr %a, align 4 cannot reach   %1 = load i32, ptr %a, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %1 = load i32, ptr %a, align 4 [ToFn]
[AA][Ret]   store i32 %add, ptr %a, align 4 can potentially reach   ret void [Intra]
[AA] check @foo from   store i32 %add, ptr %a, align 4 is not checked backwards, abort
[AA] check   %2 = load i32, ptr %a, align 4 from   store i32 %add, ptr %a, align 4 intraprocedurally
[AA]   store i32 %add, ptr %a, align 4 can potentially reach   %2 = load i32, ptr %a, align 4 [Intra]
[AAIsDead] Store has 2 potential copies.
[Attributor] Update unchanged [AAIsDead] for CtxI '  store i32 %add, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead-store

[Attributor] Update: [AAIsDead] for CtxI '  %2 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Update unchanged [AAIsDead] for CtxI '  %2 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Update: [AAIsDead] for CtxI '  store i32 %2, ptr %field12, align 4' at position {flt: [@-1]} with state assumed-dead-store

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 %2, ptr %field12, align 4 (only exact: 0)
Visit underlying object   %f = alloca i32, align 4
[AA] Object '  %f = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %0 = load i32, ptr %field11, align 4 from   store i32 %2, ptr %field12, align 4 intraprocedurally
[AA]   store i32 %2, ptr %field12, align 4 cannot reach   %0 = load i32, ptr %field11, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %0 = load i32, ptr %field11, align 4 [ToFn]
[AA][Ret]   store i32 %2, ptr %field12, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AA] check   %3 = load i32, ptr %field13, align 4 from   store i32 %2, ptr %field12, align 4 intraprocedurally
[AA]   store i32 %2, ptr %field12, align 4 can potentially reach   %3 = load i32, ptr %field13, align 4 [Intra]
[AA] check   %4 = load i32, ptr %field15, align 4 from   store i32 %2, ptr %field12, align 4 intraprocedurally
[AA]   store i32 %2, ptr %field12, align 4 cannot reach   %4 = load i32, ptr %field15, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %4 = load i32, ptr %field15, align 4 [ToFn]
[AA][Ret]   store i32 %2, ptr %field12, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AAIsDead] Store has 1 potential copies.
[Attributor] Update unchanged [AAIsDead] for CtxI '  store i32 %2, ptr %field12, align 4' at position {flt: [@-1]} with state assumed-dead-store

[Attributor] Update: [AAUnderlyingObjects] for CtxI '  %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field12 [field12@-1]} with state UnderlyingObjects inter #1 objs, intra #1 objs

[Attributor] Update unchanged [AAUnderlyingObjects] for CtxI '  %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field12 [field12@-1]} with state UnderlyingObjects inter #1 objs, intra #1 objs

[Attributor] Update: [AAPotentialValues] for CtxI '  %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field12 [field12@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

The instruction encountered was:   %f = alloca i32, align 4!
The instruction Opcode was: 31!
Was able to create AAPointer Info object [AAPointerInfo] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

[handleAllocaInst] The first offset is the start of the Alloca.
[handleAllocaInst] Offset size cannot be reduced in Alloca.
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field12 [field12@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

[Attributor] Update: [AAIsDead] for CtxI '  %3 = load i32, ptr %field13, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Update unchanged [AAIsDead] for CtxI '  %3 = load i32, ptr %field13, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Update: [AAPotentialValues] for CtxI '  %3 = load i32, ptr %field13, align 4' at position {flt: [@-1]} with state set-state(< {} >)

getPotentiallyLoadedValues!
Trying to determine the potential copies of   %3 = load i32, ptr %field13, align 4 (only exact: 1)
Visit underlying object   %f = alloca i32, align 4
[AA] Object '  %f = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %3 = load i32, ptr %field13, align 4 from   store i32 10, ptr %field1, align 4 intraprocedurally
[AA]   store i32 10, ptr %field1, align 4 cannot reach   %3 = load i32, ptr %field13, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %3 = load i32, ptr %field13, align 4 [ToFn]
[AA][Ret]   store i32 10, ptr %field1, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AA] check   %3 = load i32, ptr %field13, align 4 from   store i32 %2, ptr %field12, align 4 intraprocedurally
[AA]   store i32 %2, ptr %field12, align 4 can potentially reach   %3 = load i32, ptr %field13, align 4 [Intra]
[AA] check   %3 = load i32, ptr %field13, align 4 from   store i32 %add4, ptr %field13, align 4 intraprocedurally
[AA]   store i32 %add4, ptr %field13, align 4 cannot reach   %3 = load i32, ptr %field13, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %3 = load i32, ptr %field13, align 4 [ToFn]
[AA][Ret]   store i32 %add4, ptr %field13, align 4 can potentially reach   ret void [Intra]
[AA] check @foo from   store i32 %add4, ptr %field13, align 4 is not checked backwards, abort
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %3 = load i32, ptr %field13, align 4' at position {flt: [@-1]} with state set-state(< {} >)

[Attributor] Update: [AAUnderlyingObjects] for CtxI '  %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field13 [field13@-1]} with state UnderlyingObjects inter #1 objs, intra #1 objs

[Attributor] Update unchanged [AAUnderlyingObjects] for CtxI '  %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field13 [field13@-1]} with state UnderlyingObjects inter #1 objs, intra #1 objs

[Attributor] Update: [AAPotentialValues] for CtxI '  %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field13 [field13@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

The instruction encountered was:   %f = alloca i32, align 4!
The instruction Opcode was: 31!
Was able to create AAPointer Info object [AAPointerInfo] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

[handleAllocaInst] The first offset is the start of the Alloca.
[handleAllocaInst] Offset size cannot be reduced in Alloca.
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field13 [field13@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

[Attributor] Update: [AAIsDead] for CtxI '  store i32 %add4, ptr %field13, align 4' at position {flt: [@-1]} with state assumed-dead-store

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 %add4, ptr %field13, align 4 (only exact: 0)
Visit underlying object   %f = alloca i32, align 4
[AA] Object '  %f = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %0 = load i32, ptr %field11, align 4 from   store i32 %add4, ptr %field13, align 4 intraprocedurally
[AA]   store i32 %add4, ptr %field13, align 4 cannot reach   %0 = load i32, ptr %field11, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %0 = load i32, ptr %field11, align 4 [ToFn]
[AA][Ret]   store i32 %add4, ptr %field13, align 4 can potentially reach   ret void [Intra]
[AA] check @foo from   store i32 %add4, ptr %field13, align 4 is not checked backwards, abort
[AA] check   %3 = load i32, ptr %field13, align 4 from   store i32 %add4, ptr %field13, align 4 intraprocedurally
[AA]   store i32 %add4, ptr %field13, align 4 cannot reach   %3 = load i32, ptr %field13, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %3 = load i32, ptr %field13, align 4 [ToFn]
[AA][Ret]   store i32 %add4, ptr %field13, align 4 can potentially reach   ret void [Intra]
[AA] check @foo from   store i32 %add4, ptr %field13, align 4 is not checked backwards, abort
[AA] check   %4 = load i32, ptr %field15, align 4 from   store i32 %add4, ptr %field13, align 4 intraprocedurally
[AA]   store i32 %add4, ptr %field13, align 4 can potentially reach   %4 = load i32, ptr %field15, align 4 [Intra]
[AAIsDead] Store has 3 potential copies.
[Attributor] Update unchanged [AAIsDead] for CtxI '  store i32 %add4, ptr %field13, align 4' at position {flt: [@-1]} with state assumed-dead-store

[Attributor] Update: [AAIsDead] for CtxI '  %4 = load i32, ptr %field15, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Update unchanged [AAIsDead] for CtxI '  %4 = load i32, ptr %field15, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Update: [AAPotentialValues] for CtxI '  %4 = load i32, ptr %field15, align 4' at position {flt: [@-1]} with state set-state(< {} >)

getPotentiallyLoadedValues!
Trying to determine the potential copies of   %4 = load i32, ptr %field15, align 4 (only exact: 1)
Visit underlying object   %f = alloca i32, align 4
[AA] Object '  %f = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %4 = load i32, ptr %field15, align 4 from   store i32 10, ptr %field1, align 4 intraprocedurally
[AA]   store i32 10, ptr %field1, align 4 cannot reach   %4 = load i32, ptr %field15, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %4 = load i32, ptr %field15, align 4 [ToFn]
[AA][Ret]   store i32 10, ptr %field1, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AA] check   %4 = load i32, ptr %field15, align 4 from   store i32 %2, ptr %field12, align 4 intraprocedurally
[AA]   store i32 %2, ptr %field12, align 4 cannot reach   %4 = load i32, ptr %field15, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %4 = load i32, ptr %field15, align 4 [ToFn]
[AA][Ret]   store i32 %2, ptr %field12, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AA] check   %4 = load i32, ptr %field15, align 4 from   store i32 %add4, ptr %field13, align 4 intraprocedurally
[AA]   store i32 %add4, ptr %field13, align 4 can potentially reach   %4 = load i32, ptr %field15, align 4 [Intra]
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %4 = load i32, ptr %field15, align 4' at position {flt: [@-1]} with state set-state(< {} >)

[Attributor] Update: [AAUnderlyingObjects] for CtxI '  %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field15 [field15@-1]} with state UnderlyingObjects inter #1 objs, intra #1 objs

[Attributor] Update unchanged [AAUnderlyingObjects] for CtxI '  %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field15 [field15@-1]} with state UnderlyingObjects inter #1 objs, intra #1 objs

[Attributor] Update: [AAPotentialValues] for CtxI '  %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field15 [field15@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

The instruction encountered was:   %f = alloca i32, align 4!
The instruction Opcode was: 31!
Was able to create AAPointer Info object [AAPointerInfo] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

[handleAllocaInst] The first offset is the start of the Alloca.
[handleAllocaInst] Offset size cannot be reduced in Alloca.
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field15 [field15@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

[Attributor] Update: [AAIsDead] for CtxI '  %5 = load i32, ptr %val.addr, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Got 1 initial uses to check
[Attributor] Update unchanged [AAIsDead] for CtxI '  %5 = load i32, ptr %val.addr, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Update: [AAPotentialValues] for CtxI '  %5 = load i32, ptr %val.addr, align 4' at position {flt: [@-1]} with state set-state(< {i32 %val[3], } >)

getPotentiallyLoadedValues!
Trying to determine the potential copies of   %5 = load i32, ptr %val.addr, align 4 (only exact: 1)
Visit underlying object   %val.addr = alloca i32, align 4
[AA] Object '  %val.addr = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %5 = load i32, ptr %val.addr, align 4 from   store i32 %val, ptr %val.addr, align 4 intraprocedurally
[AA]   store i32 %val, ptr %val.addr, align 4 can potentially reach   %5 = load i32, ptr %val.addr, align 4 [Intra]
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %5 = load i32, ptr %val.addr, align 4' at position {flt: [@-1]} with state set-state(< {i32 %val[3], } >)

[Attributor] Update: [AAIsDead] for CtxI '  %add6 = add nsw i32 %4, %5' at position {flt:add6 [add6@-1]} with state assumed-dead

[Attributor] Update unchanged [AAIsDead] for CtxI '  %add6 = add nsw i32 %4, %5' at position {flt:add6 [add6@-1]} with state assumed-dead

[Attributor] Update: [AAPotentialValues] for CtxI '  %add6 = add nsw i32 %4, %5' at position {flt:add6 [add6@-1]} with state set-state(< {} >)

[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %add6 = add nsw i32 %4, %5' at position {flt:add6 [add6@-1]} with state set-state(< {} >)

[Attributor] Update: [AAIsDead] for CtxI '  %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field11 [field11@-1]} with state assumed-dead

[Attributor] Got 1 initial uses to check
[Attributor] Update unchanged [AAIsDead] for CtxI '  %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field11 [field11@-1]} with state assumed-dead

[Attributor] Update: [AAIsDead] for CtxI '  %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field15 [field15@-1]} with state assumed-dead

[Attributor] Got 1 initial uses to check
[Attributor] Update unchanged [AAIsDead] for CtxI '  %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field15 [field15@-1]} with state assumed-dead

[Attributor] Update: [AAPotentialValues] for CtxI '  %add4 = add nsw i32 %3, 1' at position {flt:add4 [add4@-1]} with state set-state(< {} >)

[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %add4 = add nsw i32 %3, 1' at position {flt:add4 [add4@-1]} with state set-state(< {} >)

[Attributor] Update: [AAIsDead] for CtxI '  %val.addr = alloca i32, align 4' at position {arg:val [val@0]} with state assumed-dead

[Attributor] Got 1 initial uses to check
[Attributor] Update unchanged [AAIsDead] for CtxI '  %val.addr = alloca i32, align 4' at position {arg:val [val@0]} with state assumed-dead

[Attributor] Update: [AAInterFnReachability] for CtxI '  call void @foo(i32 noundef 10)' at position {fn:main [main@-1]} with state #queries(1)

[Attributor] Update unchanged [AAInterFnReachability] for CtxI '  call void @foo(i32 noundef 10)' at position {fn:main [main@-1]} with state #queries(1)

[Attributor] Update: [AAIntraFnReachability] for CtxI '  call void @foo(i32 noundef 10)' at position {fn:main [main@-1]} with state #queries(0)

[Attributor] Update unchanged [AAIntraFnReachability] for CtxI '  call void @foo(i32 noundef 10)' at position {fn:main [main@-1]} with state #queries(0)

[Attributor] Update: [AAIsDead] for CtxI '  call void @foo(i32 noundef 10)' at position {cs_arg: [@0]} with state assumed-dead

[Attributor] Update unchanged [AAIsDead] for CtxI '  call void @foo(i32 noundef 10)' at position {cs_arg: [@0]} with state assumed-dead



[Attributor] #Iteration: 2, Worklist size: 2
[Attributor] #Iteration: 2, Worklist+Dependent size: 14
[Attributor] Update: [AAUnderlyingObjects] for CtxI '  %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field11 [field11@-1]} with state UnderlyingObjects inter #1 objs, intra #1 objs

[Attributor] Update unchanged [AAUnderlyingObjects] for CtxI '  %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field11 [field11@-1]} with state UnderlyingObjects inter #1 objs, intra #1 objs

[Attributor] Update: [AAIntraFnReachability] for CtxI '  %val.addr = alloca i32, align 4' at position {fn:foo [foo@-1]} with state #queries(41)

[Attributor] Update unchanged [AAIntraFnReachability] for CtxI '  %val.addr = alloca i32, align 4' at position {fn:foo [foo@-1]} with state #queries(41)

[Attributor] Update: [AAIsDead] for CtxI '  store i32 %0, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead-store

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 %0, ptr %a, align 4 (only exact: 0)
Visit underlying object   %a = alloca i32, align 4
[AA] Object '  %a = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %1 = load i32, ptr %a, align 4 from   store i32 %0, ptr %a, align 4 intraprocedurally
[AA]   store i32 %0, ptr %a, align 4 can potentially reach   %1 = load i32, ptr %a, align 4 [Intra]
[AA] check   %2 = load i32, ptr %a, align 4 from   store i32 %0, ptr %a, align 4 intraprocedurally
[AA]   store i32 %0, ptr %a, align 4 cannot reach   %2 = load i32, ptr %a, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %2 = load i32, ptr %a, align 4 [ToFn]
[AA][Ret]   store i32 %0, ptr %a, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AAIsDead] Store has 1 potential copies.
[Attributor] Update unchanged [AAIsDead] for CtxI '  store i32 %0, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead-store

[Attributor] Update: [AAIsDead] for CtxI '  store i32 %add, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead-store

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 %add, ptr %a, align 4 (only exact: 0)
Visit underlying object   %a = alloca i32, align 4
[AA] Object '  %a = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %1 = load i32, ptr %a, align 4 from   store i32 %add, ptr %a, align 4 intraprocedurally
[AA]   store i32 %add, ptr %a, align 4 cannot reach   %1 = load i32, ptr %a, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %1 = load i32, ptr %a, align 4 [ToFn]
[AA][Ret]   store i32 %add, ptr %a, align 4 can potentially reach   ret void [Intra]
[AA] check @foo from   store i32 %add, ptr %a, align 4 is not checked backwards, abort
[AA] check   %2 = load i32, ptr %a, align 4 from   store i32 %add, ptr %a, align 4 intraprocedurally
[AA]   store i32 %add, ptr %a, align 4 can potentially reach   %2 = load i32, ptr %a, align 4 [Intra]
[AAIsDead] Store has 2 potential copies.
[Attributor] Update unchanged [AAIsDead] for CtxI '  store i32 %add, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead-store

[Attributor] Update: [AAIsDead] for CtxI '  store i32 %2, ptr %field12, align 4' at position {flt: [@-1]} with state assumed-dead-store

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 %2, ptr %field12, align 4 (only exact: 0)
Visit underlying object   %f = alloca i32, align 4
[AA] Object '  %f = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %0 = load i32, ptr %field11, align 4 from   store i32 %2, ptr %field12, align 4 intraprocedurally
[AA]   store i32 %2, ptr %field12, align 4 cannot reach   %0 = load i32, ptr %field11, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %0 = load i32, ptr %field11, align 4 [ToFn]
[AA][Ret]   store i32 %2, ptr %field12, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AA] check   %3 = load i32, ptr %field13, align 4 from   store i32 %2, ptr %field12, align 4 intraprocedurally
[AA]   store i32 %2, ptr %field12, align 4 can potentially reach   %3 = load i32, ptr %field13, align 4 [Intra]
[AA] check   %4 = load i32, ptr %field15, align 4 from   store i32 %2, ptr %field12, align 4 intraprocedurally
[AA]   store i32 %2, ptr %field12, align 4 cannot reach   %4 = load i32, ptr %field15, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %4 = load i32, ptr %field15, align 4 [ToFn]
[AA][Ret]   store i32 %2, ptr %field12, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AAIsDead] Store has 1 potential copies.
[Attributor] Update unchanged [AAIsDead] for CtxI '  store i32 %2, ptr %field12, align 4' at position {flt: [@-1]} with state assumed-dead-store

[Attributor] Update: [AAPotentialValues] for CtxI '  %3 = load i32, ptr %field13, align 4' at position {flt: [@-1]} with state set-state(< {} >)

getPotentiallyLoadedValues!
Trying to determine the potential copies of   %3 = load i32, ptr %field13, align 4 (only exact: 1)
Visit underlying object   %f = alloca i32, align 4
[AA] Object '  %f = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %3 = load i32, ptr %field13, align 4 from   store i32 10, ptr %field1, align 4 intraprocedurally
[AA]   store i32 10, ptr %field1, align 4 cannot reach   %3 = load i32, ptr %field13, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %3 = load i32, ptr %field13, align 4 [ToFn]
[AA][Ret]   store i32 10, ptr %field1, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AA] check   %3 = load i32, ptr %field13, align 4 from   store i32 %2, ptr %field12, align 4 intraprocedurally
[AA]   store i32 %2, ptr %field12, align 4 can potentially reach   %3 = load i32, ptr %field13, align 4 [Intra]
[AA] check   %3 = load i32, ptr %field13, align 4 from   store i32 %add4, ptr %field13, align 4 intraprocedurally
[AA]   store i32 %add4, ptr %field13, align 4 cannot reach   %3 = load i32, ptr %field13, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %3 = load i32, ptr %field13, align 4 [ToFn]
[AA][Ret]   store i32 %add4, ptr %field13, align 4 can potentially reach   ret void [Intra]
[AA] check @foo from   store i32 %add4, ptr %field13, align 4 is not checked backwards, abort
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %3 = load i32, ptr %field13, align 4' at position {flt: [@-1]} with state set-state(< {} >)

[Attributor] Update: [AAIsDead] for CtxI '  store i32 %add4, ptr %field13, align 4' at position {flt: [@-1]} with state assumed-dead-store

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 %add4, ptr %field13, align 4 (only exact: 0)
Visit underlying object   %f = alloca i32, align 4
[AA] Object '  %f = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %0 = load i32, ptr %field11, align 4 from   store i32 %add4, ptr %field13, align 4 intraprocedurally
[AA]   store i32 %add4, ptr %field13, align 4 cannot reach   %0 = load i32, ptr %field11, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %0 = load i32, ptr %field11, align 4 [ToFn]
[AA][Ret]   store i32 %add4, ptr %field13, align 4 can potentially reach   ret void [Intra]
[AA] check @foo from   store i32 %add4, ptr %field13, align 4 is not checked backwards, abort
[AA] check   %3 = load i32, ptr %field13, align 4 from   store i32 %add4, ptr %field13, align 4 intraprocedurally
[AA]   store i32 %add4, ptr %field13, align 4 cannot reach   %3 = load i32, ptr %field13, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %3 = load i32, ptr %field13, align 4 [ToFn]
[AA][Ret]   store i32 %add4, ptr %field13, align 4 can potentially reach   ret void [Intra]
[AA] check @foo from   store i32 %add4, ptr %field13, align 4 is not checked backwards, abort
[AA] check   %4 = load i32, ptr %field15, align 4 from   store i32 %add4, ptr %field13, align 4 intraprocedurally
[AA]   store i32 %add4, ptr %field13, align 4 can potentially reach   %4 = load i32, ptr %field15, align 4 [Intra]
[AAIsDead] Store has 3 potential copies.
[Attributor] Update unchanged [AAIsDead] for CtxI '  store i32 %add4, ptr %field13, align 4' at position {flt: [@-1]} with state assumed-dead-store

[Attributor] Update: [AAPotentialValues] for CtxI '  %4 = load i32, ptr %field15, align 4' at position {flt: [@-1]} with state set-state(< {} >)

getPotentiallyLoadedValues!
Trying to determine the potential copies of   %4 = load i32, ptr %field15, align 4 (only exact: 1)
Visit underlying object   %f = alloca i32, align 4
[AA] Object '  %f = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %4 = load i32, ptr %field15, align 4 from   store i32 10, ptr %field1, align 4 intraprocedurally
[AA]   store i32 10, ptr %field1, align 4 cannot reach   %4 = load i32, ptr %field15, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %4 = load i32, ptr %field15, align 4 [ToFn]
[AA][Ret]   store i32 10, ptr %field1, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AA] check   %4 = load i32, ptr %field15, align 4 from   store i32 %2, ptr %field12, align 4 intraprocedurally
[AA]   store i32 %2, ptr %field12, align 4 cannot reach   %4 = load i32, ptr %field15, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %4 = load i32, ptr %field15, align 4 [ToFn]
[AA][Ret]   store i32 %2, ptr %field12, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AA] check   %4 = load i32, ptr %field15, align 4 from   store i32 %add4, ptr %field13, align 4 intraprocedurally
[AA]   store i32 %add4, ptr %field13, align 4 can potentially reach   %4 = load i32, ptr %field15, align 4 [Intra]
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %4 = load i32, ptr %field15, align 4' at position {flt: [@-1]} with state set-state(< {} >)

[Attributor] Update: [AAPotentialValues] for CtxI '  %5 = load i32, ptr %val.addr, align 4' at position {flt: [@-1]} with state set-state(< {i32 %val[3], } >)

getPotentiallyLoadedValues!
Trying to determine the potential copies of   %5 = load i32, ptr %val.addr, align 4 (only exact: 1)
Visit underlying object   %val.addr = alloca i32, align 4
[AA] Object '  %val.addr = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %5 = load i32, ptr %val.addr, align 4 from   store i32 %val, ptr %val.addr, align 4 intraprocedurally
[AA]   store i32 %val, ptr %val.addr, align 4 can potentially reach   %5 = load i32, ptr %val.addr, align 4 [Intra]
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %5 = load i32, ptr %val.addr, align 4' at position {flt: [@-1]} with state set-state(< {i32 %val[3], } >)

[Attributor] Update: [AAIsDead] for CtxI '  store i32 10, ptr %field1, align 4' at position {flt: [@-1]} with state assumed-dead-store

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 10, ptr %field1, align 4 (only exact: 0)
Visit underlying object   %f = alloca i32, align 4
[AA] Object '  %f = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %0 = load i32, ptr %field11, align 4 from   store i32 10, ptr %field1, align 4 intraprocedurally
[AA]   store i32 10, ptr %field1, align 4 can potentially reach   %0 = load i32, ptr %field11, align 4 [Intra]
[AA] check   %3 = load i32, ptr %field13, align 4 from   store i32 10, ptr %field1, align 4 intraprocedurally
[AA]   store i32 10, ptr %field1, align 4 cannot reach   %3 = load i32, ptr %field13, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %3 = load i32, ptr %field13, align 4 [ToFn]
[AA][Ret]   store i32 10, ptr %field1, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AA] check   %4 = load i32, ptr %field15, align 4 from   store i32 10, ptr %field1, align 4 intraprocedurally
[AA]   store i32 10, ptr %field1, align 4 cannot reach   %4 = load i32, ptr %field15, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %4 = load i32, ptr %field15, align 4 [ToFn]
[AA][Ret]   store i32 10, ptr %field1, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AAIsDead] Store has 1 potential copies.
[Attributor] Update unchanged [AAIsDead] for CtxI '  store i32 10, ptr %field1, align 4' at position {flt: [@-1]} with state assumed-dead-store

[Attributor] Update: [AAIsDead] for CtxI '  store i32 %val, ptr %val.addr, align 4' at position {flt: [@-1]} with state assumed-dead-store

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 %val, ptr %val.addr, align 4 (only exact: 0)
Visit underlying object   %val.addr = alloca i32, align 4
[AA] Object '  %val.addr = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %5 = load i32, ptr %val.addr, align 4 from   store i32 %val, ptr %val.addr, align 4 intraprocedurally
[AA]   store i32 %val, ptr %val.addr, align 4 can potentially reach   %5 = load i32, ptr %val.addr, align 4 [Intra]
[AAIsDead] Store has 1 potential copies.
[Attributor] Update unchanged [AAIsDead] for CtxI '  store i32 %val, ptr %val.addr, align 4' at position {flt: [@-1]} with state assumed-dead-store

[Attributor] Update: [AANoCapture] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state assumed not-captured

[Attributor] Got 4 initial uses to check
[Attributor] Update unchanged [AANoCapture] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state assumed not-captured

[Attributor] Update: [AANoCapture] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state assumed not-captured

[Attributor] Got 5 initial uses to check
[Attributor] Update unchanged [AANoCapture] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state assumed not-captured

[Attributor] Update: [AAPotentialValues] for CtxI '  %0 = load i32, ptr %field11, align 4' at position {flt: [@-1]} with state set-state(< {} >)

getPotentiallyLoadedValues!
Trying to determine the potential copies of   %0 = load i32, ptr %field11, align 4 (only exact: 1)
Visit underlying object   %f = alloca i32, align 4
[AA] Object '  %f = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %0 = load i32, ptr %field11, align 4 from   store i32 10, ptr %field1, align 4 intraprocedurally
[AA]   store i32 10, ptr %field1, align 4 can potentially reach   %0 = load i32, ptr %field11, align 4 [Intra]
[AA] check   %0 = load i32, ptr %field11, align 4 from   store i32 %2, ptr %field12, align 4 intraprocedurally
[AA]   store i32 %2, ptr %field12, align 4 cannot reach   %0 = load i32, ptr %field11, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %0 = load i32, ptr %field11, align 4 [ToFn]
[AA][Ret]   store i32 %2, ptr %field12, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AA] check   %0 = load i32, ptr %field11, align 4 from   store i32 %add4, ptr %field13, align 4 intraprocedurally
[AA]   store i32 %add4, ptr %field13, align 4 cannot reach   %0 = load i32, ptr %field11, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %0 = load i32, ptr %field11, align 4 [ToFn]
[AA][Ret]   store i32 %add4, ptr %field13, align 4 can potentially reach   ret void [Intra]
[AA] check @foo from   store i32 %add4, ptr %field13, align 4 is not checked backwards, abort
[Attributor] Update changed [AAPotentialValues] for CtxI '  %0 = load i32, ptr %field11, align 4' at position {flt: [@-1]} with state set-state(< {i32 10[3], } >)



[Attributor] #Iteration: 3, Worklist size: 3
[Attributor] #Iteration: 3, Worklist+Dependent size: 5
[Attributor] Update: [AAPotentialValues] for CtxI '  %0 = load i32, ptr %field11, align 4' at position {flt: [@-1]} with state set-state(< {i32 10[3], } >)

getPotentiallyLoadedValues!
Trying to determine the potential copies of   %0 = load i32, ptr %field11, align 4 (only exact: 1)
Visit underlying object   %f = alloca i32, align 4
[AA] Object '  %f = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %0 = load i32, ptr %field11, align 4 from   store i32 10, ptr %field1, align 4 intraprocedurally
[AA]   store i32 10, ptr %field1, align 4 can potentially reach   %0 = load i32, ptr %field11, align 4 [Intra]
[AA] check   %0 = load i32, ptr %field11, align 4 from   store i32 %2, ptr %field12, align 4 intraprocedurally
[AA]   store i32 %2, ptr %field12, align 4 cannot reach   %0 = load i32, ptr %field11, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %0 = load i32, ptr %field11, align 4 [ToFn]
[AA][Ret]   store i32 %2, ptr %field12, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AA] check   %0 = load i32, ptr %field11, align 4 from   store i32 %add4, ptr %field13, align 4 intraprocedurally
[AA]   store i32 %add4, ptr %field13, align 4 cannot reach   %0 = load i32, ptr %field11, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %0 = load i32, ptr %field11, align 4 [ToFn]
[AA][Ret]   store i32 %add4, ptr %field13, align 4 can potentially reach   ret void [Intra]
[AA] check @foo from   store i32 %add4, ptr %field13, align 4 is not checked backwards, abort
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %0 = load i32, ptr %field11, align 4' at position {flt: [@-1]} with state set-state(< {i32 10[3], } >)

[Attributor] Update: [AAIntraFnReachability] for CtxI '  %val.addr = alloca i32, align 4' at position {fn:foo [foo@-1]} with state #queries(44)

[Attributor] Update unchanged [AAIntraFnReachability] for CtxI '  %val.addr = alloca i32, align 4' at position {fn:foo [foo@-1]} with state #queries(44)

[Attributor] Update: [AAPointerInfo] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state PointerInfo #1 bins

[Attributor] Got 4 initial uses to check
[AAPointerInfo] Analyze   %a = alloca i32, align 4 in   store i32 %0, ptr %a, align 4
[AAPointerInfo] Analyze   %a = alloca i32, align 4 in   %1 = load i32, ptr %a, align 4
[AAPointerInfo] Analyze   %a = alloca i32, align 4 in   store i32 %add, ptr %a, align 4
[AAPointerInfo] Analyze   %a = alloca i32, align 4 in   %2 = load i32, ptr %a, align 4
Accesses by bin after update:
[0-4] : 4
     - 9 -   store i32 %0, ptr %a, align 4
       - c: i32 10
     - 5 -   %1 = load i32, ptr %a, align 4
       - c: <unknown>
     - 9 -   store i32 %add, ptr %a, align 4
     - 5 -   %2 = load i32, ptr %a, align 4
       - c: <unknown>
[Attributor] Update changed [AAPointerInfo] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state PointerInfo #1 bins

[Attributor] Update: [AAIsDead] for CtxI '  %0 = load i32, ptr %field11, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Update unchanged [AAIsDead] for CtxI '  %0 = load i32, ptr %field11, align 4' at position {flt: [@-1]} with state assumed-dead



[Attributor] #Iteration: 4, Worklist size: 1
[Attributor] #Iteration: 4, Worklist+Dependent size: 5
[Attributor] Update: [AAPointerInfo] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state PointerInfo #1 bins

[Attributor] Got 4 initial uses to check
[AAPointerInfo] Analyze   %a = alloca i32, align 4 in   store i32 %0, ptr %a, align 4
[AAPointerInfo] Analyze   %a = alloca i32, align 4 in   %1 = load i32, ptr %a, align 4
[AAPointerInfo] Analyze   %a = alloca i32, align 4 in   store i32 %add, ptr %a, align 4
[AAPointerInfo] Analyze   %a = alloca i32, align 4 in   %2 = load i32, ptr %a, align 4
Accesses by bin after update:
[0-4] : 4
     - 9 -   store i32 %0, ptr %a, align 4
       - c: i32 10
     - 5 -   %1 = load i32, ptr %a, align 4
       - c: <unknown>
     - 9 -   store i32 %add, ptr %a, align 4
     - 5 -   %2 = load i32, ptr %a, align 4
       - c: <unknown>
[Attributor] Update unchanged [AAPointerInfo] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state PointerInfo #1 bins

[Attributor] Update: [AAIsDead] for CtxI '  store i32 %0, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead-store

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 %0, ptr %a, align 4 (only exact: 0)
Visit underlying object   %a = alloca i32, align 4
[AA] Object '  %a = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %1 = load i32, ptr %a, align 4 from   store i32 %0, ptr %a, align 4 intraprocedurally
[AA]   store i32 %0, ptr %a, align 4 can potentially reach   %1 = load i32, ptr %a, align 4 [Intra]
[AA] check   %2 = load i32, ptr %a, align 4 from   store i32 %0, ptr %a, align 4 intraprocedurally
[AA]   store i32 %0, ptr %a, align 4 cannot reach   %2 = load i32, ptr %a, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %2 = load i32, ptr %a, align 4 [ToFn]
[AA][Ret]   store i32 %0, ptr %a, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AAIsDead] Store has 1 potential copies.
[Attributor] Update unchanged [AAIsDead] for CtxI '  store i32 %0, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead-store

[Attributor] Update: [AAIsDead] for CtxI '  store i32 %add, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead-store

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 %add, ptr %a, align 4 (only exact: 0)
Visit underlying object   %a = alloca i32, align 4
[AA] Object '  %a = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %1 = load i32, ptr %a, align 4 from   store i32 %add, ptr %a, align 4 intraprocedurally
[AA]   store i32 %add, ptr %a, align 4 cannot reach   %1 = load i32, ptr %a, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %1 = load i32, ptr %a, align 4 [ToFn]
[AA][Ret]   store i32 %add, ptr %a, align 4 can potentially reach   ret void [Intra]
[AA] check @foo from   store i32 %add, ptr %a, align 4 is not checked backwards, abort
[AA] check   %2 = load i32, ptr %a, align 4 from   store i32 %add, ptr %a, align 4 intraprocedurally
[AA]   store i32 %add, ptr %a, align 4 can potentially reach   %2 = load i32, ptr %a, align 4 [Intra]
[AAIsDead] Store has 2 potential copies.
[Attributor] Update unchanged [AAIsDead] for CtxI '  store i32 %add, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead-store

[Attributor] Update: [AAPotentialValues] for CtxI '  %2 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state set-state(< {} >)

getPotentiallyLoadedValues!
Trying to determine the potential copies of   %2 = load i32, ptr %a, align 4 (only exact: 1)
Visit underlying object   %a = alloca i32, align 4
[AA] Object '  %a = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %2 = load i32, ptr %a, align 4 from   store i32 %0, ptr %a, align 4 intraprocedurally
[AA]   store i32 %0, ptr %a, align 4 cannot reach   %2 = load i32, ptr %a, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %2 = load i32, ptr %a, align 4 [ToFn]
[AA][Ret]   store i32 %0, ptr %a, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AA] check   %2 = load i32, ptr %a, align 4 from   store i32 %add, ptr %a, align 4 intraprocedurally
[AA]   store i32 %add, ptr %a, align 4 can potentially reach   %2 = load i32, ptr %a, align 4 [Intra]
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %2 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state set-state(< {} >)

[Attributor] Update: [AAPotentialValues] for CtxI '  %1 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state set-state(< {} >)

getPotentiallyLoadedValues!
Trying to determine the potential copies of   %1 = load i32, ptr %a, align 4 (only exact: 1)
Visit underlying object   %a = alloca i32, align 4
[AA] Object '  %a = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %1 = load i32, ptr %a, align 4 from   store i32 %0, ptr %a, align 4 intraprocedurally
[AA]   store i32 %0, ptr %a, align 4 can potentially reach   %1 = load i32, ptr %a, align 4 [Intra]
[AA] check   %1 = load i32, ptr %a, align 4 from   store i32 %add, ptr %a, align 4 intraprocedurally
[AA]   store i32 %add, ptr %a, align 4 cannot reach   %1 = load i32, ptr %a, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %1 = load i32, ptr %a, align 4 [ToFn]
[AA][Ret]   store i32 %add, ptr %a, align 4 can potentially reach   ret void [Intra]
[AA] check @foo from   store i32 %add, ptr %a, align 4 is not checked backwards, abort
[Attributor] Update changed [AAPotentialValues] for CtxI '  %1 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state set-state(< {i32 10[3], } >)



[Attributor] #Iteration: 5, Worklist size: 1
[Attributor] #Iteration: 5, Worklist+Dependent size: 3
[Attributor] Update: [AAPotentialValues] for CtxI '  %1 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state set-state(< {i32 10[3], } >)

getPotentiallyLoadedValues!
Trying to determine the potential copies of   %1 = load i32, ptr %a, align 4 (only exact: 1)
Visit underlying object   %a = alloca i32, align 4
[AA] Object '  %a = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %1 = load i32, ptr %a, align 4 from   store i32 %0, ptr %a, align 4 intraprocedurally
[AA]   store i32 %0, ptr %a, align 4 can potentially reach   %1 = load i32, ptr %a, align 4 [Intra]
[AA] check   %1 = load i32, ptr %a, align 4 from   store i32 %add, ptr %a, align 4 intraprocedurally
[AA]   store i32 %add, ptr %a, align 4 cannot reach   %1 = load i32, ptr %a, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %1 = load i32, ptr %a, align 4 [ToFn]
[AA][Ret]   store i32 %add, ptr %a, align 4 can potentially reach   ret void [Intra]
[AA] check @foo from   store i32 %add, ptr %a, align 4 is not checked backwards, abort
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %1 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state set-state(< {i32 10[3], } >)

[Attributor] Update: [AAPotentialValues] for CtxI '  %add = add nsw i32 %1, 1' at position {flt:add [add@-1]} with state set-state(< {} >)

Generic inst   %add = add nsw i32 %1, 1 assumed simplified to i32 11
[Attributor] Update changed [AAPotentialValues] for CtxI '  %add = add nsw i32 %1, 1' at position {flt:add [add@-1]} with state set-state(< {i32 11[3], } >)

[Attributor] Update: [AAIsDead] for CtxI '  %1 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Update unchanged [AAIsDead] for CtxI '  %1 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead



[Attributor] #Iteration: 6, Worklist size: 2
[Attributor] #Iteration: 6, Worklist+Dependent size: 3
[Attributor] Update: [AAPotentialValues] for CtxI '  %add = add nsw i32 %1, 1' at position {flt:add [add@-1]} with state set-state(< {i32 11[3], } >)

Generic inst   %add = add nsw i32 %1, 1 assumed simplified to i32 11
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %add = add nsw i32 %1, 1' at position {flt:add [add@-1]} with state set-state(< {i32 11[3], } >)

[Attributor] Update: [AAPointerInfo] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state PointerInfo #1 bins

[Attributor] Got 4 initial uses to check
[AAPointerInfo] Analyze   %a = alloca i32, align 4 in   store i32 %0, ptr %a, align 4
[AAPointerInfo] Analyze   %a = alloca i32, align 4 in   %1 = load i32, ptr %a, align 4
[AAPointerInfo] Analyze   %a = alloca i32, align 4 in   store i32 %add, ptr %a, align 4
[AAPointerInfo] Analyze   %a = alloca i32, align 4 in   %2 = load i32, ptr %a, align 4
Accesses by bin after update:
[0-4] : 4
     - 9 -   store i32 %0, ptr %a, align 4
       - c: i32 10
     - 5 -   %1 = load i32, ptr %a, align 4
       - c: <unknown>
     - 9 -   store i32 %add, ptr %a, align 4
       - c: i32 11
     - 5 -   %2 = load i32, ptr %a, align 4
       - c: <unknown>
[Attributor] Update changed [AAPointerInfo] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state PointerInfo #1 bins



[Attributor] #Iteration: 7, Worklist size: 1
[Attributor] #Iteration: 7, Worklist+Dependent size: 5
[Attributor] Update: [AAPointerInfo] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state PointerInfo #1 bins

[Attributor] Got 4 initial uses to check
[AAPointerInfo] Analyze   %a = alloca i32, align 4 in   store i32 %0, ptr %a, align 4
[AAPointerInfo] Analyze   %a = alloca i32, align 4 in   %1 = load i32, ptr %a, align 4
[AAPointerInfo] Analyze   %a = alloca i32, align 4 in   store i32 %add, ptr %a, align 4
[AAPointerInfo] Analyze   %a = alloca i32, align 4 in   %2 = load i32, ptr %a, align 4
Accesses by bin after update:
[0-4] : 4
     - 9 -   store i32 %0, ptr %a, align 4
       - c: i32 10
     - 5 -   %1 = load i32, ptr %a, align 4
       - c: <unknown>
     - 9 -   store i32 %add, ptr %a, align 4
       - c: i32 11
     - 5 -   %2 = load i32, ptr %a, align 4
       - c: <unknown>
[Attributor] Update unchanged [AAPointerInfo] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state PointerInfo #1 bins

[Attributor] Update: [AAIsDead] for CtxI '  store i32 %0, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead-store

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 %0, ptr %a, align 4 (only exact: 0)
Visit underlying object   %a = alloca i32, align 4
[AA] Object '  %a = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %1 = load i32, ptr %a, align 4 from   store i32 %0, ptr %a, align 4 intraprocedurally
[AA]   store i32 %0, ptr %a, align 4 can potentially reach   %1 = load i32, ptr %a, align 4 [Intra]
[AA] check   %2 = load i32, ptr %a, align 4 from   store i32 %0, ptr %a, align 4 intraprocedurally
[AA]   store i32 %0, ptr %a, align 4 cannot reach   %2 = load i32, ptr %a, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %2 = load i32, ptr %a, align 4 [ToFn]
[AA][Ret]   store i32 %0, ptr %a, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AAIsDead] Store has 1 potential copies.
[Attributor] Update unchanged [AAIsDead] for CtxI '  store i32 %0, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead-store

[Attributor] Update: [AAIsDead] for CtxI '  store i32 %add, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead-store

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 %add, ptr %a, align 4 (only exact: 0)
Visit underlying object   %a = alloca i32, align 4
[AA] Object '  %a = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %1 = load i32, ptr %a, align 4 from   store i32 %add, ptr %a, align 4 intraprocedurally
[AA]   store i32 %add, ptr %a, align 4 cannot reach   %1 = load i32, ptr %a, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %1 = load i32, ptr %a, align 4 [ToFn]
[AA][Ret]   store i32 %add, ptr %a, align 4 can potentially reach   ret void [Intra]
[AA] check @foo from   store i32 %add, ptr %a, align 4 is not checked backwards, abort
[AA] check   %2 = load i32, ptr %a, align 4 from   store i32 %add, ptr %a, align 4 intraprocedurally
[AA]   store i32 %add, ptr %a, align 4 can potentially reach   %2 = load i32, ptr %a, align 4 [Intra]
[AAIsDead] Store has 2 potential copies.
[Attributor] Update unchanged [AAIsDead] for CtxI '  store i32 %add, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead-store

[Attributor] Update: [AAPotentialValues] for CtxI '  %2 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state set-state(< {} >)

getPotentiallyLoadedValues!
Trying to determine the potential copies of   %2 = load i32, ptr %a, align 4 (only exact: 1)
Visit underlying object   %a = alloca i32, align 4
[AA] Object '  %a = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %2 = load i32, ptr %a, align 4 from   store i32 %0, ptr %a, align 4 intraprocedurally
[AA]   store i32 %0, ptr %a, align 4 cannot reach   %2 = load i32, ptr %a, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %2 = load i32, ptr %a, align 4 [ToFn]
[AA][Ret]   store i32 %0, ptr %a, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AA] check   %2 = load i32, ptr %a, align 4 from   store i32 %add, ptr %a, align 4 intraprocedurally
[AA]   store i32 %add, ptr %a, align 4 can potentially reach   %2 = load i32, ptr %a, align 4 [Intra]
[Attributor] Update changed [AAPotentialValues] for CtxI '  %2 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state set-state(< {i32 11[3], } >)

[Attributor] Update: [AAPotentialValues] for CtxI '  %1 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state set-state(< {i32 10[3], } >)

getPotentiallyLoadedValues!
Trying to determine the potential copies of   %1 = load i32, ptr %a, align 4 (only exact: 1)
Visit underlying object   %a = alloca i32, align 4
[AA] Object '  %a = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %1 = load i32, ptr %a, align 4 from   store i32 %0, ptr %a, align 4 intraprocedurally
[AA]   store i32 %0, ptr %a, align 4 can potentially reach   %1 = load i32, ptr %a, align 4 [Intra]
[AA] check   %1 = load i32, ptr %a, align 4 from   store i32 %add, ptr %a, align 4 intraprocedurally
[AA]   store i32 %add, ptr %a, align 4 cannot reach   %1 = load i32, ptr %a, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %1 = load i32, ptr %a, align 4 [ToFn]
[AA][Ret]   store i32 %add, ptr %a, align 4 can potentially reach   ret void [Intra]
[AA] check @foo from   store i32 %add, ptr %a, align 4 is not checked backwards, abort
[Attributor] Update changed [AAPotentialValues] for CtxI '  %1 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state set-state(< {i32 10[3], i32 11[3], } >)



[Attributor] #Iteration: 8, Worklist size: 3
[Attributor] #Iteration: 8, Worklist+Dependent size: 7
[Attributor] Update: [AAPotentialValues] for CtxI '  %2 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state set-state(< {i32 11[3], } >)

getPotentiallyLoadedValues!
Trying to determine the potential copies of   %2 = load i32, ptr %a, align 4 (only exact: 1)
Visit underlying object   %a = alloca i32, align 4
[AA] Object '  %a = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %2 = load i32, ptr %a, align 4 from   store i32 %0, ptr %a, align 4 intraprocedurally
[AA]   store i32 %0, ptr %a, align 4 cannot reach   %2 = load i32, ptr %a, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %2 = load i32, ptr %a, align 4 [ToFn]
[AA][Ret]   store i32 %0, ptr %a, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AA] check   %2 = load i32, ptr %a, align 4 from   store i32 %add, ptr %a, align 4 intraprocedurally
[AA]   store i32 %add, ptr %a, align 4 can potentially reach   %2 = load i32, ptr %a, align 4 [Intra]
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %2 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state set-state(< {i32 11[3], } >)

[Attributor] Update: [AAPotentialValues] for CtxI '  %1 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state set-state(< {i32 10[3], i32 11[3], } >)

getPotentiallyLoadedValues!
Trying to determine the potential copies of   %1 = load i32, ptr %a, align 4 (only exact: 1)
Visit underlying object   %a = alloca i32, align 4
[AA] Object '  %a = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %1 = load i32, ptr %a, align 4 from   store i32 %0, ptr %a, align 4 intraprocedurally
[AA]   store i32 %0, ptr %a, align 4 can potentially reach   %1 = load i32, ptr %a, align 4 [Intra]
[AA] check   %1 = load i32, ptr %a, align 4 from   store i32 %add, ptr %a, align 4 intraprocedurally
[AA]   store i32 %add, ptr %a, align 4 cannot reach   %1 = load i32, ptr %a, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %1 = load i32, ptr %a, align 4 [ToFn]
[AA][Ret]   store i32 %add, ptr %a, align 4 can potentially reach   ret void [Intra]
[AA] check @foo from   store i32 %add, ptr %a, align 4 is not checked backwards, abort
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %1 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state set-state(< {i32 10[3], i32 11[3], } >)

[Attributor] Update: [AAIsDead] for CtxI '  %2 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Update unchanged [AAIsDead] for CtxI '  %2 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Update: [AAPointerInfo] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

[Attributor] Got 5 initial uses to check
[AAPointerInfo] Analyze   %f = alloca i32, align 4 in   %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] GEP offset is  constant   %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] Analyze   %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   store i32 10, ptr %field1, align 4
[AAPointerInfo] Analyze   %f = alloca i32, align 4 in   %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] GEP offset is  constant   %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] Analyze   %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   %0 = load i32, ptr %field11, align 4
[AAPointerInfo] Analyze   %f = alloca i32, align 4 in   %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] GEP offset is  constant   %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] Analyze   %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   store i32 %2, ptr %field12, align 4
[AAPointerInfo] Analyze   %f = alloca i32, align 4 in   %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] GEP offset is  constant   %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] Analyze   %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   %3 = load i32, ptr %field13, align 4
[AAPointerInfo] Analyze   %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   store i32 %add4, ptr %field13, align 4
[AAPointerInfo] Analyze   %f = alloca i32, align 4 in   %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] GEP offset is  constant   %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] Analyze   %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   %4 = load i32, ptr %field15, align 4
Accesses by bin after update:
[0-4] : 6
     - 9 -   store i32 10, ptr %field1, align 4
       - c: i32 10
     - 5 -   %0 = load i32, ptr %field11, align 4
       - c: <unknown>
     - 9 -   store i32 %2, ptr %field12, align 4
       - c: i32 11
     - 5 -   %3 = load i32, ptr %field13, align 4
       - c: <unknown>
     - 9 -   store i32 %add4, ptr %field13, align 4
     - 5 -   %4 = load i32, ptr %field15, align 4
       - c: <unknown>
[Attributor] Update changed [AAPointerInfo] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

[Attributor] Update: [AAPotentialValues] for CtxI '  %add = add nsw i32 %1, 1' at position {flt:add [add@-1]} with state set-state(< {i32 11[3], } >)

[Attributor] Update changed [AAPotentialValues] for CtxI '  %add = add nsw i32 %1, 1' at position {flt:add [add@-1]} with state set-state(< {  %add = add nsw i32 %1, 1[3], } >)

[Attributor] Update: [AAIsDead] for CtxI '  %1 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Got 1 initial uses to check
[Attributor] Update: [AAIsDead] for CtxI '  %add = add nsw i32 %1, 1' at position {flt:add [add@-1]} with state assumed-dead

[Attributor] Got 1 initial uses to check
[Attributor] Update unchanged [AAIsDead] for CtxI '  %add = add nsw i32 %1, 1' at position {flt:add [add@-1]} with state assumed-dead

[Attributor] Update unchanged [AAIsDead] for CtxI '  %1 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead



[Attributor] #Iteration: 9, Worklist size: 3
[Attributor] #Iteration: 9, Worklist+Dependent size: 16
[Attributor] Update: [AAPointerInfo] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

[Attributor] Got 5 initial uses to check
[AAPointerInfo] Analyze   %f = alloca i32, align 4 in   %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] GEP offset is  constant   %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] Analyze   %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   store i32 10, ptr %field1, align 4
[AAPointerInfo] Analyze   %f = alloca i32, align 4 in   %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] GEP offset is  constant   %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] Analyze   %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   %0 = load i32, ptr %field11, align 4
[AAPointerInfo] Analyze   %f = alloca i32, align 4 in   %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] GEP offset is  constant   %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] Analyze   %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   store i32 %2, ptr %field12, align 4
[AAPointerInfo] Analyze   %f = alloca i32, align 4 in   %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] GEP offset is  constant   %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] Analyze   %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   %3 = load i32, ptr %field13, align 4
[AAPointerInfo] Analyze   %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   store i32 %add4, ptr %field13, align 4
[AAPointerInfo] Analyze   %f = alloca i32, align 4 in   %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] GEP offset is  constant   %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] Analyze   %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   %4 = load i32, ptr %field15, align 4
Accesses by bin after update:
[0-4] : 6
     - 9 -   store i32 10, ptr %field1, align 4
       - c: i32 10
     - 5 -   %0 = load i32, ptr %field11, align 4
       - c: <unknown>
     - 9 -   store i32 %2, ptr %field12, align 4
       - c: i32 11
     - 5 -   %3 = load i32, ptr %field13, align 4
       - c: <unknown>
     - 9 -   store i32 %add4, ptr %field13, align 4
     - 5 -   %4 = load i32, ptr %field15, align 4
       - c: <unknown>
[Attributor] Update unchanged [AAPointerInfo] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

[Attributor] Update: [AAIsDead] for CtxI '  %add = add nsw i32 %1, 1' at position {flt:add [add@-1]} with state assumed-dead

[Attributor] Got 1 initial uses to check
[Attributor] Update unchanged [AAIsDead] for CtxI '  %add = add nsw i32 %1, 1' at position {flt:add [add@-1]} with state assumed-dead

[Attributor] Update: [AAPotentialValues] for CtxI '  %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field1 [field1@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

The instruction encountered was:   %f = alloca i32, align 4!
The instruction Opcode was: 31!
Was able to create AAPointer Info object [AAPointerInfo] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

[handleAllocaInst] The first offset is the start of the Alloca.
[handleAllocaInst] Offset size cannot be reduced in Alloca.
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field1 [field1@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

[Attributor] Update: [AAPotentialValues] for CtxI '  %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field12 [field12@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

The instruction encountered was:   %f = alloca i32, align 4!
The instruction Opcode was: 31!
Was able to create AAPointer Info object [AAPointerInfo] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

[handleAllocaInst] The first offset is the start of the Alloca.
[handleAllocaInst] Offset size cannot be reduced in Alloca.
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field12 [field12@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

[Attributor] Update: [AAIsDead] for CtxI '  store i32 %2, ptr %field12, align 4' at position {flt: [@-1]} with state assumed-dead-store

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 %2, ptr %field12, align 4 (only exact: 0)
Visit underlying object   %f = alloca i32, align 4
[AA] Object '  %f = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %0 = load i32, ptr %field11, align 4 from   store i32 %2, ptr %field12, align 4 intraprocedurally
[AA]   store i32 %2, ptr %field12, align 4 cannot reach   %0 = load i32, ptr %field11, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %0 = load i32, ptr %field11, align 4 [ToFn]
[AA][Ret]   store i32 %2, ptr %field12, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AA] check   %3 = load i32, ptr %field13, align 4 from   store i32 %2, ptr %field12, align 4 intraprocedurally
[AA]   store i32 %2, ptr %field12, align 4 can potentially reach   %3 = load i32, ptr %field13, align 4 [Intra]
[AA] check   %4 = load i32, ptr %field15, align 4 from   store i32 %2, ptr %field12, align 4 intraprocedurally
[AA]   store i32 %2, ptr %field12, align 4 cannot reach   %4 = load i32, ptr %field15, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %4 = load i32, ptr %field15, align 4 [ToFn]
[AA][Ret]   store i32 %2, ptr %field12, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AAIsDead] Store has 1 potential copies.
[Attributor] Update unchanged [AAIsDead] for CtxI '  store i32 %2, ptr %field12, align 4' at position {flt: [@-1]} with state assumed-dead-store

[Attributor] Update: [AAPotentialValues] for CtxI '  %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field13 [field13@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

The instruction encountered was:   %f = alloca i32, align 4!
The instruction Opcode was: 31!
Was able to create AAPointer Info object [AAPointerInfo] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

[handleAllocaInst] The first offset is the start of the Alloca.
[handleAllocaInst] Offset size cannot be reduced in Alloca.
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field13 [field13@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

[Attributor] Update: [AAPotentialValues] for CtxI '  %3 = load i32, ptr %field13, align 4' at position {flt: [@-1]} with state set-state(< {} >)

getPotentiallyLoadedValues!
Trying to determine the potential copies of   %3 = load i32, ptr %field13, align 4 (only exact: 1)
Visit underlying object   %f = alloca i32, align 4
[AA] Object '  %f = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %3 = load i32, ptr %field13, align 4 from   store i32 10, ptr %field1, align 4 intraprocedurally
[AA]   store i32 10, ptr %field1, align 4 cannot reach   %3 = load i32, ptr %field13, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %3 = load i32, ptr %field13, align 4 [ToFn]
[AA][Ret]   store i32 10, ptr %field1, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AA] check   %3 = load i32, ptr %field13, align 4 from   store i32 %2, ptr %field12, align 4 intraprocedurally
[AA]   store i32 %2, ptr %field12, align 4 can potentially reach   %3 = load i32, ptr %field13, align 4 [Intra]
[AA] check   %3 = load i32, ptr %field13, align 4 from   store i32 %add4, ptr %field13, align 4 intraprocedurally
[AA]   store i32 %add4, ptr %field13, align 4 cannot reach   %3 = load i32, ptr %field13, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %3 = load i32, ptr %field13, align 4 [ToFn]
[AA][Ret]   store i32 %add4, ptr %field13, align 4 can potentially reach   ret void [Intra]
[AA] check @foo from   store i32 %add4, ptr %field13, align 4 is not checked backwards, abort
[Attributor] Update changed [AAPotentialValues] for CtxI '  %3 = load i32, ptr %field13, align 4' at position {flt: [@-1]} with state set-state(< {i32 11[3], } >)

[Attributor] Update: [AAIsDead] for CtxI '  store i32 %add4, ptr %field13, align 4' at position {flt: [@-1]} with state assumed-dead-store

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 %add4, ptr %field13, align 4 (only exact: 0)
Visit underlying object   %f = alloca i32, align 4
[AA] Object '  %f = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %0 = load i32, ptr %field11, align 4 from   store i32 %add4, ptr %field13, align 4 intraprocedurally
[AA]   store i32 %add4, ptr %field13, align 4 cannot reach   %0 = load i32, ptr %field11, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %0 = load i32, ptr %field11, align 4 [ToFn]
[AA][Ret]   store i32 %add4, ptr %field13, align 4 can potentially reach   ret void [Intra]
[AA] check @foo from   store i32 %add4, ptr %field13, align 4 is not checked backwards, abort
[AA] check   %3 = load i32, ptr %field13, align 4 from   store i32 %add4, ptr %field13, align 4 intraprocedurally
[AA]   store i32 %add4, ptr %field13, align 4 cannot reach   %3 = load i32, ptr %field13, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %3 = load i32, ptr %field13, align 4 [ToFn]
[AA][Ret]   store i32 %add4, ptr %field13, align 4 can potentially reach   ret void [Intra]
[AA] check @foo from   store i32 %add4, ptr %field13, align 4 is not checked backwards, abort
[AA] check   %4 = load i32, ptr %field15, align 4 from   store i32 %add4, ptr %field13, align 4 intraprocedurally
[AA]   store i32 %add4, ptr %field13, align 4 can potentially reach   %4 = load i32, ptr %field15, align 4 [Intra]
[AAIsDead] Store has 3 potential copies.
[Attributor] Update unchanged [AAIsDead] for CtxI '  store i32 %add4, ptr %field13, align 4' at position {flt: [@-1]} with state assumed-dead-store

[Attributor] Update: [AAPotentialValues] for CtxI '  %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field15 [field15@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

The instruction encountered was:   %f = alloca i32, align 4!
The instruction Opcode was: 31!
Was able to create AAPointer Info object [AAPointerInfo] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

[handleAllocaInst] The first offset is the start of the Alloca.
[handleAllocaInst] Offset size cannot be reduced in Alloca.
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field15 [field15@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

[Attributor] Update: [AAPotentialValues] for CtxI '  %4 = load i32, ptr %field15, align 4' at position {flt: [@-1]} with state set-state(< {} >)

getPotentiallyLoadedValues!
Trying to determine the potential copies of   %4 = load i32, ptr %field15, align 4 (only exact: 1)
Visit underlying object   %f = alloca i32, align 4
[AA] Object '  %f = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %4 = load i32, ptr %field15, align 4 from   store i32 10, ptr %field1, align 4 intraprocedurally
[AA]   store i32 10, ptr %field1, align 4 cannot reach   %4 = load i32, ptr %field15, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %4 = load i32, ptr %field15, align 4 [ToFn]
[AA][Ret]   store i32 10, ptr %field1, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AA] check   %4 = load i32, ptr %field15, align 4 from   store i32 %2, ptr %field12, align 4 intraprocedurally
[AA]   store i32 %2, ptr %field12, align 4 cannot reach   %4 = load i32, ptr %field15, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %4 = load i32, ptr %field15, align 4 [ToFn]
[AA][Ret]   store i32 %2, ptr %field12, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AA] check   %4 = load i32, ptr %field15, align 4 from   store i32 %add4, ptr %field13, align 4 intraprocedurally
[AA]   store i32 %add4, ptr %field13, align 4 can potentially reach   %4 = load i32, ptr %field15, align 4 [Intra]
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %4 = load i32, ptr %field15, align 4' at position {flt: [@-1]} with state set-state(< {} >)

[Attributor] Update: [AAIsDead] for CtxI '  store i32 10, ptr %field1, align 4' at position {flt: [@-1]} with state assumed-dead-store

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 10, ptr %field1, align 4 (only exact: 0)
Visit underlying object   %f = alloca i32, align 4
[AA] Object '  %f = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %0 = load i32, ptr %field11, align 4 from   store i32 10, ptr %field1, align 4 intraprocedurally
[AA]   store i32 10, ptr %field1, align 4 can potentially reach   %0 = load i32, ptr %field11, align 4 [Intra]
[AA] check   %3 = load i32, ptr %field13, align 4 from   store i32 10, ptr %field1, align 4 intraprocedurally
[AA]   store i32 10, ptr %field1, align 4 cannot reach   %3 = load i32, ptr %field13, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %3 = load i32, ptr %field13, align 4 [ToFn]
[AA][Ret]   store i32 10, ptr %field1, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AA] check   %4 = load i32, ptr %field15, align 4 from   store i32 10, ptr %field1, align 4 intraprocedurally
[AA]   store i32 10, ptr %field1, align 4 cannot reach   %4 = load i32, ptr %field15, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %4 = load i32, ptr %field15, align 4 [ToFn]
[AA][Ret]   store i32 10, ptr %field1, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AAIsDead] Store has 1 potential copies.
[Attributor] Update unchanged [AAIsDead] for CtxI '  store i32 10, ptr %field1, align 4' at position {flt: [@-1]} with state assumed-dead-store

[Attributor] Update: [AAPotentialValues] for CtxI '  %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field11 [field11@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

The instruction encountered was:   %f = alloca i32, align 4!
The instruction Opcode was: 31!
Was able to create AAPointer Info object [AAPointerInfo] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

[handleAllocaInst] The first offset is the start of the Alloca.
[handleAllocaInst] Offset size cannot be reduced in Alloca.
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field11 [field11@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

[Attributor] Update: [AAPotentialValues] for CtxI '  %0 = load i32, ptr %field11, align 4' at position {flt: [@-1]} with state set-state(< {i32 10[3], } >)

getPotentiallyLoadedValues!
Trying to determine the potential copies of   %0 = load i32, ptr %field11, align 4 (only exact: 1)
Visit underlying object   %f = alloca i32, align 4
[AA] Object '  %f = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %0 = load i32, ptr %field11, align 4 from   store i32 10, ptr %field1, align 4 intraprocedurally
[AA]   store i32 10, ptr %field1, align 4 can potentially reach   %0 = load i32, ptr %field11, align 4 [Intra]
[AA] check   %0 = load i32, ptr %field11, align 4 from   store i32 %2, ptr %field12, align 4 intraprocedurally
[AA]   store i32 %2, ptr %field12, align 4 cannot reach   %0 = load i32, ptr %field11, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %0 = load i32, ptr %field11, align 4 [ToFn]
[AA][Ret]   store i32 %2, ptr %field12, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AA] check   %0 = load i32, ptr %field11, align 4 from   store i32 %add4, ptr %field13, align 4 intraprocedurally
[AA]   store i32 %add4, ptr %field13, align 4 cannot reach   %0 = load i32, ptr %field11, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %0 = load i32, ptr %field11, align 4 [ToFn]
[AA][Ret]   store i32 %add4, ptr %field13, align 4 can potentially reach   ret void [Intra]
[AA] check @foo from   store i32 %add4, ptr %field13, align 4 is not checked backwards, abort
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %0 = load i32, ptr %field11, align 4' at position {flt: [@-1]} with state set-state(< {i32 10[3], } >)

[Attributor] Update: [AAPointerInfo] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state PointerInfo #1 bins

[Attributor] Got 4 initial uses to check
[AAPointerInfo] Analyze   %a = alloca i32, align 4 in   store i32 %0, ptr %a, align 4
[AAPointerInfo] Analyze   %a = alloca i32, align 4 in   %1 = load i32, ptr %a, align 4
[AAPointerInfo] Analyze   %a = alloca i32, align 4 in   store i32 %add, ptr %a, align 4
[AAPointerInfo] Analyze   %a = alloca i32, align 4 in   %2 = load i32, ptr %a, align 4
Accesses by bin after update:
[0-4] : 4
     - 9 -   store i32 %0, ptr %a, align 4
       - c: i32 10
     - 5 -   %1 = load i32, ptr %a, align 4
       - c: <unknown>
     - 9 -   store i32 %add, ptr %a, align 4
       - c: <unknown>
     - 5 -   %2 = load i32, ptr %a, align 4
       - c: <unknown>
[Attributor] Update changed [AAPointerInfo] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state PointerInfo #1 bins

[Attributor] Update: [AAIsDead] for CtxI '  %1 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Got 1 initial uses to check
[Attributor] Update unchanged [AAIsDead] for CtxI '  %1 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead



[Attributor] #Iteration: 10, Worklist size: 2
[Attributor] #Iteration: 10, Worklist+Dependent size: 8
[Attributor] Update: [AAPotentialValues] for CtxI '  %3 = load i32, ptr %field13, align 4' at position {flt: [@-1]} with state set-state(< {i32 11[3], } >)

getPotentiallyLoadedValues!
Trying to determine the potential copies of   %3 = load i32, ptr %field13, align 4 (only exact: 1)
Visit underlying object   %f = alloca i32, align 4
[AA] Object '  %f = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %3 = load i32, ptr %field13, align 4 from   store i32 10, ptr %field1, align 4 intraprocedurally
[AA]   store i32 10, ptr %field1, align 4 cannot reach   %3 = load i32, ptr %field13, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %3 = load i32, ptr %field13, align 4 [ToFn]
[AA][Ret]   store i32 10, ptr %field1, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AA] check   %3 = load i32, ptr %field13, align 4 from   store i32 %2, ptr %field12, align 4 intraprocedurally
[AA]   store i32 %2, ptr %field12, align 4 can potentially reach   %3 = load i32, ptr %field13, align 4 [Intra]
[AA] check   %3 = load i32, ptr %field13, align 4 from   store i32 %add4, ptr %field13, align 4 intraprocedurally
[AA]   store i32 %add4, ptr %field13, align 4 cannot reach   %3 = load i32, ptr %field13, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %3 = load i32, ptr %field13, align 4 [ToFn]
[AA][Ret]   store i32 %add4, ptr %field13, align 4 can potentially reach   ret void [Intra]
[AA] check @foo from   store i32 %add4, ptr %field13, align 4 is not checked backwards, abort
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %3 = load i32, ptr %field13, align 4' at position {flt: [@-1]} with state set-state(< {i32 11[3], } >)

[Attributor] Update: [AAPointerInfo] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state PointerInfo #1 bins

[Attributor] Got 4 initial uses to check
[AAPointerInfo] Analyze   %a = alloca i32, align 4 in   store i32 %0, ptr %a, align 4
[AAPointerInfo] Analyze   %a = alloca i32, align 4 in   %1 = load i32, ptr %a, align 4
[AAPointerInfo] Analyze   %a = alloca i32, align 4 in   store i32 %add, ptr %a, align 4
[AAPointerInfo] Analyze   %a = alloca i32, align 4 in   %2 = load i32, ptr %a, align 4
Accesses by bin after update:
[0-4] : 4
     - 9 -   store i32 %0, ptr %a, align 4
       - c: i32 10
     - 5 -   %1 = load i32, ptr %a, align 4
       - c: <unknown>
     - 9 -   store i32 %add, ptr %a, align 4
       - c: <unknown>
     - 5 -   %2 = load i32, ptr %a, align 4
       - c: <unknown>
[Attributor] Update unchanged [AAPointerInfo] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state PointerInfo #1 bins

[Attributor] Update: [AAIsDead] for CtxI '  %3 = load i32, ptr %field13, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Update unchanged [AAIsDead] for CtxI '  %3 = load i32, ptr %field13, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Update: [AAPotentialValues] for CtxI '  %add4 = add nsw i32 %3, 1' at position {flt:add4 [add4@-1]} with state set-state(< {} >)

Generic inst   %add4 = add nsw i32 %3, 1 assumed simplified to i32 12
[Attributor] Update changed [AAPotentialValues] for CtxI '  %add4 = add nsw i32 %3, 1' at position {flt:add4 [add4@-1]} with state set-state(< {i32 12[3], } >)

[Attributor] Update: [AAIsDead] for CtxI '  store i32 %0, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead-store

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 %0, ptr %a, align 4 (only exact: 0)
Visit underlying object   %a = alloca i32, align 4
[AA] Object '  %a = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %1 = load i32, ptr %a, align 4 from   store i32 %0, ptr %a, align 4 intraprocedurally
[AA]   store i32 %0, ptr %a, align 4 can potentially reach   %1 = load i32, ptr %a, align 4 [Intra]
[AA] check   %2 = load i32, ptr %a, align 4 from   store i32 %0, ptr %a, align 4 intraprocedurally
[AA]   store i32 %0, ptr %a, align 4 cannot reach   %2 = load i32, ptr %a, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %2 = load i32, ptr %a, align 4 [ToFn]
[AA][Ret]   store i32 %0, ptr %a, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AAIsDead] Store has 1 potential copies.
[Attributor] Update unchanged [AAIsDead] for CtxI '  store i32 %0, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead-store

[Attributor] Update: [AAIsDead] for CtxI '  store i32 %add, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead-store

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 %add, ptr %a, align 4 (only exact: 0)
Visit underlying object   %a = alloca i32, align 4
[AA] Object '  %a = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %1 = load i32, ptr %a, align 4 from   store i32 %add, ptr %a, align 4 intraprocedurally
[AA]   store i32 %add, ptr %a, align 4 cannot reach   %1 = load i32, ptr %a, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %1 = load i32, ptr %a, align 4 [ToFn]
[AA][Ret]   store i32 %add, ptr %a, align 4 can potentially reach   ret void [Intra]
[AA] check @foo from   store i32 %add, ptr %a, align 4 is not checked backwards, abort
[AA] check   %2 = load i32, ptr %a, align 4 from   store i32 %add, ptr %a, align 4 intraprocedurally
[AA]   store i32 %add, ptr %a, align 4 can potentially reach   %2 = load i32, ptr %a, align 4 [Intra]
[AAIsDead] Store has 2 potential copies.
[Attributor] Update unchanged [AAIsDead] for CtxI '  store i32 %add, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead-store

[Attributor] Update: [AAPotentialValues] for CtxI '  %2 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state set-state(< {i32 11[3], } >)

getPotentiallyLoadedValues!
Trying to determine the potential copies of   %2 = load i32, ptr %a, align 4 (only exact: 1)
Visit underlying object   %a = alloca i32, align 4
[AA] Object '  %a = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %2 = load i32, ptr %a, align 4 from   store i32 %0, ptr %a, align 4 intraprocedurally
[AA]   store i32 %0, ptr %a, align 4 cannot reach   %2 = load i32, ptr %a, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %2 = load i32, ptr %a, align 4 [ToFn]
[AA][Ret]   store i32 %0, ptr %a, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AA] check   %2 = load i32, ptr %a, align 4 from   store i32 %add, ptr %a, align 4 intraprocedurally
[AA]   store i32 %add, ptr %a, align 4 can potentially reach   %2 = load i32, ptr %a, align 4 [Intra]
[Attributor] Update: [AAInstanceInfo] for CtxI '  %add = add nsw i32 %1, 1' at position {flt:add [add@-1]} with state <unique [fAa]>

[Attributor] Got 1 initial uses to check
getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 %add, ptr %a, align 4 (only exact: 1)
Visit underlying object   %a = alloca i32, align 4
[AA] Object '  %a = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %1 = load i32, ptr %a, align 4 from   store i32 %add, ptr %a, align 4 intraprocedurally
[AA]   store i32 %add, ptr %a, align 4 cannot reach   %1 = load i32, ptr %a, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %1 = load i32, ptr %a, align 4 [ToFn]
[AA][Ret]   store i32 %add, ptr %a, align 4 can potentially reach   ret void [Intra]
[AA] check @foo from   store i32 %add, ptr %a, align 4 is not checked backwards, abort
[AA] check   %2 = load i32, ptr %a, align 4 from   store i32 %add, ptr %a, align 4 intraprocedurally
[AA]   store i32 %add, ptr %a, align 4 can potentially reach   %2 = load i32, ptr %a, align 4 [Intra]
[Attributor] Update: [AAInstanceInfo] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state <unique [fAa]>

[Attributor] Got 4 initial uses to check
[Attributor] Update unchanged [AAInstanceInfo] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state <unique [fAa]>

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 %2, ptr %field12, align 4 (only exact: 1)
Visit underlying object   %f = alloca i32, align 4
[AA] Object '  %f = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %0 = load i32, ptr %field11, align 4 from   store i32 %2, ptr %field12, align 4 intraprocedurally
[AA]   store i32 %2, ptr %field12, align 4 cannot reach   %0 = load i32, ptr %field11, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %0 = load i32, ptr %field11, align 4 [ToFn]
[AA][Ret]   store i32 %2, ptr %field12, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AA] check   %3 = load i32, ptr %field13, align 4 from   store i32 %2, ptr %field12, align 4 intraprocedurally
[AA]   store i32 %2, ptr %field12, align 4 can potentially reach   %3 = load i32, ptr %field13, align 4 [Intra]
[AA] check   %4 = load i32, ptr %field15, align 4 from   store i32 %2, ptr %field12, align 4 intraprocedurally
[AA]   store i32 %2, ptr %field12, align 4 cannot reach   %4 = load i32, ptr %field15, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %4 = load i32, ptr %field15, align 4 [ToFn]
[AA][Ret]   store i32 %2, ptr %field12, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[Attributor] Update: [AAInstanceInfo] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state <unique [fAa]>

[Attributor] Got 5 initial uses to check
[Attributor] Update unchanged [AAInstanceInfo] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state <unique [fAa]>

[Attributor] Update changed [AAInstanceInfo] for CtxI '  %add = add nsw i32 %1, 1' at position {flt:add [add@-1]} with state <unknown>

[AAPotentialValues] Not all potentially loaded values are dynamically unique:   %2 = load i32, ptr %a, align 4
[Attributor] Update changed [AAPotentialValues] for CtxI '  %2 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state set-state(< {  %2 = load i32, ptr %a, align 4[3], } >)

[Attributor] Update: [AAPotentialValues] for CtxI '  %1 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state set-state(< {i32 10[3], i32 11[3], } >)

getPotentiallyLoadedValues!
Trying to determine the potential copies of   %1 = load i32, ptr %a, align 4 (only exact: 1)
Visit underlying object   %a = alloca i32, align 4
[AA] Object '  %a = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %1 = load i32, ptr %a, align 4 from   store i32 %0, ptr %a, align 4 intraprocedurally
[AA]   store i32 %0, ptr %a, align 4 can potentially reach   %1 = load i32, ptr %a, align 4 [Intra]
[AA] check   %1 = load i32, ptr %a, align 4 from   store i32 %add, ptr %a, align 4 intraprocedurally
[AA]   store i32 %add, ptr %a, align 4 cannot reach   %1 = load i32, ptr %a, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %1 = load i32, ptr %a, align 4 [ToFn]
[AA][Ret]   store i32 %add, ptr %a, align 4 can potentially reach   ret void [Intra]
[AA] check @foo from   store i32 %add, ptr %a, align 4 is not checked backwards, abort
[AAPotentialValues] Not all potentially loaded values are dynamically unique:   %1 = load i32, ptr %a, align 4
[Attributor] Update changed [AAPotentialValues] for CtxI '  %1 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state set-state(< {  %1 = load i32, ptr %a, align 4[3], } >)



[Attributor] #Iteration: 11, Worklist size: 7
[Attributor] #Iteration: 11, Worklist+Dependent size: 10
[Attributor] Update: [AAPotentialValues] for CtxI '  %add4 = add nsw i32 %3, 1' at position {flt:add4 [add4@-1]} with state set-state(< {i32 12[3], } >)

Generic inst   %add4 = add nsw i32 %3, 1 assumed simplified to i32 12
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %add4 = add nsw i32 %3, 1' at position {flt:add4 [add4@-1]} with state set-state(< {i32 12[3], } >)

[Attributor] Update: [AAPointerInfo] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

[Attributor] Got 5 initial uses to check
[AAPointerInfo] Analyze   %f = alloca i32, align 4 in   %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] GEP offset is  constant   %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] Analyze   %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   store i32 10, ptr %field1, align 4
[AAPointerInfo] Analyze   %f = alloca i32, align 4 in   %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] GEP offset is  constant   %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] Analyze   %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   %0 = load i32, ptr %field11, align 4
[AAPointerInfo] Analyze   %f = alloca i32, align 4 in   %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] GEP offset is  constant   %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] Analyze   %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   store i32 %2, ptr %field12, align 4
[AAPointerInfo] Analyze   %f = alloca i32, align 4 in   %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] GEP offset is  constant   %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] Analyze   %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   %3 = load i32, ptr %field13, align 4
[AAPointerInfo] Analyze   %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   store i32 %add4, ptr %field13, align 4
[AAPointerInfo] Analyze   %f = alloca i32, align 4 in   %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] GEP offset is  constant   %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] Analyze   %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   %4 = load i32, ptr %field15, align 4
Accesses by bin after update:
[0-4] : 6
     - 9 -   store i32 10, ptr %field1, align 4
       - c: i32 10
     - 5 -   %0 = load i32, ptr %field11, align 4
       - c: <unknown>
     - 9 -   store i32 %2, ptr %field12, align 4
       - c: <unknown>
     - 5 -   %3 = load i32, ptr %field13, align 4
       - c: <unknown>
     - 9 -   store i32 %add4, ptr %field13, align 4
       - c: i32 12
     - 5 -   %4 = load i32, ptr %field15, align 4
       - c: <unknown>
[Attributor] Update changed [AAPointerInfo] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

[Attributor] Update: [AAIsDead] for CtxI '  %2 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Got 1 initial uses to check
[Attributor] Update unchanged [AAIsDead] for CtxI '  %2 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Update: [AAIsDead] for CtxI '  %1 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Got 1 initial uses to check
[Attributor] Update unchanged [AAIsDead] for CtxI '  %1 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead



[Attributor] #Iteration: 12, Worklist size: 1
[Attributor] #Iteration: 12, Worklist+Dependent size: 12
[Attributor] Update: [AAPointerInfo] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

[Attributor] Got 5 initial uses to check
[AAPointerInfo] Analyze   %f = alloca i32, align 4 in   %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] GEP offset is  constant   %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] Analyze   %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   store i32 10, ptr %field1, align 4
[AAPointerInfo] Analyze   %f = alloca i32, align 4 in   %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] GEP offset is  constant   %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] Analyze   %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   %0 = load i32, ptr %field11, align 4
[AAPointerInfo] Analyze   %f = alloca i32, align 4 in   %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] GEP offset is  constant   %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] Analyze   %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   store i32 %2, ptr %field12, align 4
[AAPointerInfo] Analyze   %f = alloca i32, align 4 in   %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] GEP offset is  constant   %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] Analyze   %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   %3 = load i32, ptr %field13, align 4
[AAPointerInfo] Analyze   %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   store i32 %add4, ptr %field13, align 4
[AAPointerInfo] Analyze   %f = alloca i32, align 4 in   %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] GEP offset is  constant   %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] Analyze   %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   %4 = load i32, ptr %field15, align 4
Accesses by bin after update:
[0-4] : 6
     - 9 -   store i32 10, ptr %field1, align 4
       - c: i32 10
     - 5 -   %0 = load i32, ptr %field11, align 4
       - c: <unknown>
     - 9 -   store i32 %2, ptr %field12, align 4
       - c: <unknown>
     - 5 -   %3 = load i32, ptr %field13, align 4
       - c: <unknown>
     - 9 -   store i32 %add4, ptr %field13, align 4
       - c: i32 12
     - 5 -   %4 = load i32, ptr %field15, align 4
       - c: <unknown>
[Attributor] Update unchanged [AAPointerInfo] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

[Attributor] Update: [AAPotentialValues] for CtxI '  %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field1 [field1@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

The instruction encountered was:   %f = alloca i32, align 4!
The instruction Opcode was: 31!
Was able to create AAPointer Info object [AAPointerInfo] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

[handleAllocaInst] The first offset is the start of the Alloca.
[handleAllocaInst] Offset size cannot be reduced in Alloca.
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field1 [field1@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

[Attributor] Update: [AAPotentialValues] for CtxI '  %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field12 [field12@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

The instruction encountered was:   %f = alloca i32, align 4!
The instruction Opcode was: 31!
Was able to create AAPointer Info object [AAPointerInfo] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

[handleAllocaInst] The first offset is the start of the Alloca.
[handleAllocaInst] Offset size cannot be reduced in Alloca.
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field12 [field12@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

[Attributor] Update: [AAIsDead] for CtxI '  store i32 %2, ptr %field12, align 4' at position {flt: [@-1]} with state assumed-dead-store

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 %2, ptr %field12, align 4 (only exact: 0)
Visit underlying object   %f = alloca i32, align 4
[AA] Object '  %f = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %0 = load i32, ptr %field11, align 4 from   store i32 %2, ptr %field12, align 4 intraprocedurally
[AA]   store i32 %2, ptr %field12, align 4 cannot reach   %0 = load i32, ptr %field11, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %0 = load i32, ptr %field11, align 4 [ToFn]
[AA][Ret]   store i32 %2, ptr %field12, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AA] check   %3 = load i32, ptr %field13, align 4 from   store i32 %2, ptr %field12, align 4 intraprocedurally
[AA]   store i32 %2, ptr %field12, align 4 can potentially reach   %3 = load i32, ptr %field13, align 4 [Intra]
[AA] check   %4 = load i32, ptr %field15, align 4 from   store i32 %2, ptr %field12, align 4 intraprocedurally
[AA]   store i32 %2, ptr %field12, align 4 cannot reach   %4 = load i32, ptr %field15, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %4 = load i32, ptr %field15, align 4 [ToFn]
[AA][Ret]   store i32 %2, ptr %field12, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AAIsDead] Store has 1 potential copies.
[Attributor] Update unchanged [AAIsDead] for CtxI '  store i32 %2, ptr %field12, align 4' at position {flt: [@-1]} with state assumed-dead-store

[Attributor] Update: [AAPotentialValues] for CtxI '  %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field13 [field13@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

The instruction encountered was:   %f = alloca i32, align 4!
The instruction Opcode was: 31!
Was able to create AAPointer Info object [AAPointerInfo] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

[handleAllocaInst] The first offset is the start of the Alloca.
[handleAllocaInst] Offset size cannot be reduced in Alloca.
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field13 [field13@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

[Attributor] Update: [AAPotentialValues] for CtxI '  %3 = load i32, ptr %field13, align 4' at position {flt: [@-1]} with state set-state(< {i32 11[3], } >)

getPotentiallyLoadedValues!
Trying to determine the potential copies of   %3 = load i32, ptr %field13, align 4 (only exact: 1)
Visit underlying object   %f = alloca i32, align 4
[AA] Object '  %f = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %3 = load i32, ptr %field13, align 4 from   store i32 10, ptr %field1, align 4 intraprocedurally
[AA]   store i32 10, ptr %field1, align 4 cannot reach   %3 = load i32, ptr %field13, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %3 = load i32, ptr %field13, align 4 [ToFn]
[AA][Ret]   store i32 10, ptr %field1, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AA] check   %3 = load i32, ptr %field13, align 4 from   store i32 %2, ptr %field12, align 4 intraprocedurally
[AA]   store i32 %2, ptr %field12, align 4 can potentially reach   %3 = load i32, ptr %field13, align 4 [Intra]
[AA] check   %3 = load i32, ptr %field13, align 4 from   store i32 %add4, ptr %field13, align 4 intraprocedurally
[AA]   store i32 %add4, ptr %field13, align 4 cannot reach   %3 = load i32, ptr %field13, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %3 = load i32, ptr %field13, align 4 [ToFn]
[AA][Ret]   store i32 %add4, ptr %field13, align 4 can potentially reach   ret void [Intra]
[AA] check @foo from   store i32 %add4, ptr %field13, align 4 is not checked backwards, abort
[Attributor] Update: [AAInstanceInfo] for CtxI '  %2 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state <unique [fAa]>

[Attributor] Got 1 initial uses to check
getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 %2, ptr %field12, align 4 (only exact: 1)
Visit underlying object   %f = alloca i32, align 4
[AA] Object '  %f = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %0 = load i32, ptr %field11, align 4 from   store i32 %2, ptr %field12, align 4 intraprocedurally
[AA]   store i32 %2, ptr %field12, align 4 cannot reach   %0 = load i32, ptr %field11, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %0 = load i32, ptr %field11, align 4 [ToFn]
[AA][Ret]   store i32 %2, ptr %field12, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AA] check   %3 = load i32, ptr %field13, align 4 from   store i32 %2, ptr %field12, align 4 intraprocedurally
[AA]   store i32 %2, ptr %field12, align 4 can potentially reach   %3 = load i32, ptr %field13, align 4 [Intra]
[AA] check   %4 = load i32, ptr %field15, align 4 from   store i32 %2, ptr %field12, align 4 intraprocedurally
[AA]   store i32 %2, ptr %field12, align 4 cannot reach   %4 = load i32, ptr %field15, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %4 = load i32, ptr %field15, align 4 [ToFn]
[AA][Ret]   store i32 %2, ptr %field12, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[Attributor] Update changed [AAInstanceInfo] for CtxI '  %2 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state <unknown>

[AAPotentialValues] Not all potentially loaded values are dynamically unique:   %3 = load i32, ptr %field13, align 4
[Attributor] Update changed [AAPotentialValues] for CtxI '  %3 = load i32, ptr %field13, align 4' at position {flt: [@-1]} with state set-state(< {  %3 = load i32, ptr %field13, align 4[3], } >)

[Attributor] Update: [AAIsDead] for CtxI '  store i32 %add4, ptr %field13, align 4' at position {flt: [@-1]} with state assumed-dead-store

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 %add4, ptr %field13, align 4 (only exact: 0)
Visit underlying object   %f = alloca i32, align 4
[AA] Object '  %f = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %0 = load i32, ptr %field11, align 4 from   store i32 %add4, ptr %field13, align 4 intraprocedurally
[AA]   store i32 %add4, ptr %field13, align 4 cannot reach   %0 = load i32, ptr %field11, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %0 = load i32, ptr %field11, align 4 [ToFn]
[AA][Ret]   store i32 %add4, ptr %field13, align 4 can potentially reach   ret void [Intra]
[AA] check @foo from   store i32 %add4, ptr %field13, align 4 is not checked backwards, abort
[AA] check   %3 = load i32, ptr %field13, align 4 from   store i32 %add4, ptr %field13, align 4 intraprocedurally
[AA]   store i32 %add4, ptr %field13, align 4 cannot reach   %3 = load i32, ptr %field13, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %3 = load i32, ptr %field13, align 4 [ToFn]
[AA][Ret]   store i32 %add4, ptr %field13, align 4 can potentially reach   ret void [Intra]
[AA] check @foo from   store i32 %add4, ptr %field13, align 4 is not checked backwards, abort
[AA] check   %4 = load i32, ptr %field15, align 4 from   store i32 %add4, ptr %field13, align 4 intraprocedurally
[AA]   store i32 %add4, ptr %field13, align 4 can potentially reach   %4 = load i32, ptr %field15, align 4 [Intra]
[AAIsDead] Store has 3 potential copies.
[Attributor] Update unchanged [AAIsDead] for CtxI '  store i32 %add4, ptr %field13, align 4' at position {flt: [@-1]} with state assumed-dead-store

[Attributor] Update: [AAPotentialValues] for CtxI '  %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field15 [field15@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

The instruction encountered was:   %f = alloca i32, align 4!
The instruction Opcode was: 31!
Was able to create AAPointer Info object [AAPointerInfo] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

[handleAllocaInst] The first offset is the start of the Alloca.
[handleAllocaInst] Offset size cannot be reduced in Alloca.
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field15 [field15@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

[Attributor] Update: [AAPotentialValues] for CtxI '  %4 = load i32, ptr %field15, align 4' at position {flt: [@-1]} with state set-state(< {} >)

getPotentiallyLoadedValues!
Trying to determine the potential copies of   %4 = load i32, ptr %field15, align 4 (only exact: 1)
Visit underlying object   %f = alloca i32, align 4
[AA] Object '  %f = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %4 = load i32, ptr %field15, align 4 from   store i32 10, ptr %field1, align 4 intraprocedurally
[AA]   store i32 10, ptr %field1, align 4 cannot reach   %4 = load i32, ptr %field15, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %4 = load i32, ptr %field15, align 4 [ToFn]
[AA][Ret]   store i32 10, ptr %field1, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AA] check   %4 = load i32, ptr %field15, align 4 from   store i32 %2, ptr %field12, align 4 intraprocedurally
[AA]   store i32 %2, ptr %field12, align 4 cannot reach   %4 = load i32, ptr %field15, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %4 = load i32, ptr %field15, align 4 [ToFn]
[AA][Ret]   store i32 %2, ptr %field12, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AA] check   %4 = load i32, ptr %field15, align 4 from   store i32 %add4, ptr %field13, align 4 intraprocedurally
[AA]   store i32 %add4, ptr %field13, align 4 can potentially reach   %4 = load i32, ptr %field15, align 4 [Intra]
[Attributor] Update changed [AAPotentialValues] for CtxI '  %4 = load i32, ptr %field15, align 4' at position {flt: [@-1]} with state set-state(< {i32 12[3], } >)

[Attributor] Update: [AAIsDead] for CtxI '  store i32 10, ptr %field1, align 4' at position {flt: [@-1]} with state assumed-dead-store

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 10, ptr %field1, align 4 (only exact: 0)
Visit underlying object   %f = alloca i32, align 4
[AA] Object '  %f = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %0 = load i32, ptr %field11, align 4 from   store i32 10, ptr %field1, align 4 intraprocedurally
[AA]   store i32 10, ptr %field1, align 4 can potentially reach   %0 = load i32, ptr %field11, align 4 [Intra]
[AA] check   %3 = load i32, ptr %field13, align 4 from   store i32 10, ptr %field1, align 4 intraprocedurally
[AA]   store i32 10, ptr %field1, align 4 cannot reach   %3 = load i32, ptr %field13, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %3 = load i32, ptr %field13, align 4 [ToFn]
[AA][Ret]   store i32 10, ptr %field1, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AA] check   %4 = load i32, ptr %field15, align 4 from   store i32 10, ptr %field1, align 4 intraprocedurally
[AA]   store i32 10, ptr %field1, align 4 cannot reach   %4 = load i32, ptr %field15, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %4 = load i32, ptr %field15, align 4 [ToFn]
[AA][Ret]   store i32 10, ptr %field1, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AAIsDead] Store has 1 potential copies.
[Attributor] Update unchanged [AAIsDead] for CtxI '  store i32 10, ptr %field1, align 4' at position {flt: [@-1]} with state assumed-dead-store

[Attributor] Update: [AAPotentialValues] for CtxI '  %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field11 [field11@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

The instruction encountered was:   %f = alloca i32, align 4!
The instruction Opcode was: 31!
Was able to create AAPointer Info object [AAPointerInfo] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

[handleAllocaInst] The first offset is the start of the Alloca.
[handleAllocaInst] Offset size cannot be reduced in Alloca.
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field11 [field11@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

[Attributor] Update: [AAPotentialValues] for CtxI '  %0 = load i32, ptr %field11, align 4' at position {flt: [@-1]} with state set-state(< {i32 10[3], } >)

getPotentiallyLoadedValues!
Trying to determine the potential copies of   %0 = load i32, ptr %field11, align 4 (only exact: 1)
Visit underlying object   %f = alloca i32, align 4
[AA] Object '  %f = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %0 = load i32, ptr %field11, align 4 from   store i32 10, ptr %field1, align 4 intraprocedurally
[AA]   store i32 10, ptr %field1, align 4 can potentially reach   %0 = load i32, ptr %field11, align 4 [Intra]
[AA] check   %0 = load i32, ptr %field11, align 4 from   store i32 %2, ptr %field12, align 4 intraprocedurally
[AA]   store i32 %2, ptr %field12, align 4 cannot reach   %0 = load i32, ptr %field11, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %0 = load i32, ptr %field11, align 4 [ToFn]
[AA][Ret]   store i32 %2, ptr %field12, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AA] check   %0 = load i32, ptr %field11, align 4 from   store i32 %add4, ptr %field13, align 4 intraprocedurally
[AA]   store i32 %add4, ptr %field13, align 4 cannot reach   %0 = load i32, ptr %field11, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %0 = load i32, ptr %field11, align 4 [ToFn]
[AA][Ret]   store i32 %add4, ptr %field13, align 4 can potentially reach   ret void [Intra]
[AA] check @foo from   store i32 %add4, ptr %field13, align 4 is not checked backwards, abort
[Attributor] Update changed [AAPotentialValues] for CtxI '  %0 = load i32, ptr %field11, align 4' at position {flt: [@-1]} with state set-state(< {i32 10[3], i32 12[3], } >)



[Attributor] #Iteration: 13, Worklist size: 5
[Attributor] #Iteration: 13, Worklist+Dependent size: 11
[Attributor] Update: [AAPotentialValues] for CtxI '  %4 = load i32, ptr %field15, align 4' at position {flt: [@-1]} with state set-state(< {i32 12[3], } >)

getPotentiallyLoadedValues!
Trying to determine the potential copies of   %4 = load i32, ptr %field15, align 4 (only exact: 1)
Visit underlying object   %f = alloca i32, align 4
[AA] Object '  %f = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %4 = load i32, ptr %field15, align 4 from   store i32 10, ptr %field1, align 4 intraprocedurally
[AA]   store i32 10, ptr %field1, align 4 cannot reach   %4 = load i32, ptr %field15, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %4 = load i32, ptr %field15, align 4 [ToFn]
[AA][Ret]   store i32 10, ptr %field1, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AA] check   %4 = load i32, ptr %field15, align 4 from   store i32 %2, ptr %field12, align 4 intraprocedurally
[AA]   store i32 %2, ptr %field12, align 4 cannot reach   %4 = load i32, ptr %field15, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %4 = load i32, ptr %field15, align 4 [ToFn]
[AA][Ret]   store i32 %2, ptr %field12, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AA] check   %4 = load i32, ptr %field15, align 4 from   store i32 %add4, ptr %field13, align 4 intraprocedurally
[AA]   store i32 %add4, ptr %field13, align 4 can potentially reach   %4 = load i32, ptr %field15, align 4 [Intra]
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %4 = load i32, ptr %field15, align 4' at position {flt: [@-1]} with state set-state(< {i32 12[3], } >)

[Attributor] Update: [AAPotentialValues] for CtxI '  %0 = load i32, ptr %field11, align 4' at position {flt: [@-1]} with state set-state(< {i32 10[3], i32 12[3], } >)

getPotentiallyLoadedValues!
Trying to determine the potential copies of   %0 = load i32, ptr %field11, align 4 (only exact: 1)
Visit underlying object   %f = alloca i32, align 4
[AA] Object '  %f = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %0 = load i32, ptr %field11, align 4 from   store i32 10, ptr %field1, align 4 intraprocedurally
[AA]   store i32 10, ptr %field1, align 4 can potentially reach   %0 = load i32, ptr %field11, align 4 [Intra]
[AA] check   %0 = load i32, ptr %field11, align 4 from   store i32 %2, ptr %field12, align 4 intraprocedurally
[AA]   store i32 %2, ptr %field12, align 4 cannot reach   %0 = load i32, ptr %field11, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %0 = load i32, ptr %field11, align 4 [ToFn]
[AA][Ret]   store i32 %2, ptr %field12, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AA] check   %0 = load i32, ptr %field11, align 4 from   store i32 %add4, ptr %field13, align 4 intraprocedurally
[AA]   store i32 %add4, ptr %field13, align 4 cannot reach   %0 = load i32, ptr %field11, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %0 = load i32, ptr %field11, align 4 [ToFn]
[AA][Ret]   store i32 %add4, ptr %field13, align 4 can potentially reach   ret void [Intra]
[AA] check @foo from   store i32 %add4, ptr %field13, align 4 is not checked backwards, abort
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %0 = load i32, ptr %field11, align 4' at position {flt: [@-1]} with state set-state(< {i32 10[3], i32 12[3], } >)

[Attributor] Update: [AAIsDead] for CtxI '  %3 = load i32, ptr %field13, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Got 1 initial uses to check
[Attributor] Update: [AAIsDead] for CtxI '  %add4 = add nsw i32 %3, 1' at position {flt:add4 [add4@-1]} with state assumed-dead

[Attributor] Update unchanged [AAIsDead] for CtxI '  %add4 = add nsw i32 %3, 1' at position {flt:add4 [add4@-1]} with state assumed-dead

[Attributor] Update unchanged [AAIsDead] for CtxI '  %3 = load i32, ptr %field13, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Update: [AAPotentialValues] for CtxI '  %add4 = add nsw i32 %3, 1' at position {flt:add4 [add4@-1]} with state set-state(< {i32 12[3], } >)

[Attributor] Update changed [AAPotentialValues] for CtxI '  %add4 = add nsw i32 %3, 1' at position {flt:add4 [add4@-1]} with state set-state(< {  %add4 = add nsw i32 %3, 1[3], } >)

[Attributor] Update: [AAIsDead] for CtxI '  %4 = load i32, ptr %field15, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Update unchanged [AAIsDead] for CtxI '  %4 = load i32, ptr %field15, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Update: [AAPotentialValues] for CtxI '  %add6 = add nsw i32 %4, %5' at position {flt:add6 [add6@-1]} with state set-state(< {} >)

[Attributor] Update changed [AAPotentialValues] for CtxI '  %add6 = add nsw i32 %4, %5' at position {flt:add6 [add6@-1]} with state set-state(< {  %add6 = add nsw i32 %4, %5[3], } >)

[Attributor] Update: [AAPointerInfo] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state PointerInfo #1 bins

[Attributor] Got 4 initial uses to check
[AAPointerInfo] Analyze   %a = alloca i32, align 4 in   store i32 %0, ptr %a, align 4
[AAPointerInfo] Analyze   %a = alloca i32, align 4 in   %1 = load i32, ptr %a, align 4
[AAPointerInfo] Analyze   %a = alloca i32, align 4 in   store i32 %add, ptr %a, align 4
[AAPointerInfo] Analyze   %a = alloca i32, align 4 in   %2 = load i32, ptr %a, align 4
Accesses by bin after update:
[0-4] : 4
     - 9 -   store i32 %0, ptr %a, align 4
       - c: <unknown>
     - 5 -   %1 = load i32, ptr %a, align 4
       - c: <unknown>
     - 9 -   store i32 %add, ptr %a, align 4
       - c: <unknown>
     - 5 -   %2 = load i32, ptr %a, align 4
       - c: <unknown>
[Attributor] Update changed [AAPointerInfo] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state PointerInfo #1 bins

[Attributor] Update: [AAIsDead] for CtxI '  %0 = load i32, ptr %field11, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Got 1 initial uses to check
[Attributor] Update unchanged [AAIsDead] for CtxI '  %0 = load i32, ptr %field11, align 4' at position {flt: [@-1]} with state assumed-dead



[Attributor] #Iteration: 14, Worklist size: 4
[Attributor] #Iteration: 14, Worklist+Dependent size: 9
[Attributor] Update: [AAPointerInfo] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state PointerInfo #1 bins

[Attributor] Got 4 initial uses to check
[AAPointerInfo] Analyze   %a = alloca i32, align 4 in   store i32 %0, ptr %a, align 4
[AAPointerInfo] Analyze   %a = alloca i32, align 4 in   %1 = load i32, ptr %a, align 4
[AAPointerInfo] Analyze   %a = alloca i32, align 4 in   store i32 %add, ptr %a, align 4
[AAPointerInfo] Analyze   %a = alloca i32, align 4 in   %2 = load i32, ptr %a, align 4
Accesses by bin after update:
[0-4] : 4
     - 9 -   store i32 %0, ptr %a, align 4
       - c: <unknown>
     - 5 -   %1 = load i32, ptr %a, align 4
       - c: <unknown>
     - 9 -   store i32 %add, ptr %a, align 4
       - c: <unknown>
     - 5 -   %2 = load i32, ptr %a, align 4
       - c: <unknown>
[Attributor] Update unchanged [AAPointerInfo] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state PointerInfo #1 bins

[Attributor] Update: [AAIsDead] for CtxI '  %add4 = add nsw i32 %3, 1' at position {flt:add4 [add4@-1]} with state assumed-dead

[Attributor] Got 1 initial uses to check
[Attributor] Update unchanged [AAIsDead] for CtxI '  %add4 = add nsw i32 %3, 1' at position {flt:add4 [add4@-1]} with state assumed-dead

[Attributor] Update: [AAPointerInfo] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

[Attributor] Got 5 initial uses to check
[AAPointerInfo] Analyze   %f = alloca i32, align 4 in   %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] GEP offset is  constant   %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] Analyze   %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   store i32 10, ptr %field1, align 4
[AAPointerInfo] Analyze   %f = alloca i32, align 4 in   %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] GEP offset is  constant   %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] Analyze   %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   %0 = load i32, ptr %field11, align 4
[AAPointerInfo] Analyze   %f = alloca i32, align 4 in   %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] GEP offset is  constant   %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] Analyze   %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   store i32 %2, ptr %field12, align 4
[AAPointerInfo] Analyze   %f = alloca i32, align 4 in   %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] GEP offset is  constant   %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] Analyze   %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   %3 = load i32, ptr %field13, align 4
[AAPointerInfo] Analyze   %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   store i32 %add4, ptr %field13, align 4
[AAPointerInfo] Analyze   %f = alloca i32, align 4 in   %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] GEP offset is  constant   %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] Analyze   %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   %4 = load i32, ptr %field15, align 4
Accesses by bin after update:
[0-4] : 6
     - 9 -   store i32 10, ptr %field1, align 4
       - c: i32 10
     - 5 -   %0 = load i32, ptr %field11, align 4
       - c: <unknown>
     - 9 -   store i32 %2, ptr %field12, align 4
       - c: <unknown>
     - 5 -   %3 = load i32, ptr %field13, align 4
       - c: <unknown>
     - 9 -   store i32 %add4, ptr %field13, align 4
       - c: <unknown>
     - 5 -   %4 = load i32, ptr %field15, align 4
       - c: <unknown>
[Attributor] Update changed [AAPointerInfo] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

[Attributor] Update: [AAPointerInfo] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

[Attributor] Got 5 initial uses to check
[AAPointerInfo] Analyze   %f = alloca i32, align 4 in   %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] GEP offset is  constant   %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] Analyze   %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   store i32 10, ptr %field1, align 4
[AAPointerInfo] Analyze   %f = alloca i32, align 4 in   %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] GEP offset is  constant   %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] Analyze   %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   %0 = load i32, ptr %field11, align 4
[AAPointerInfo] Analyze   %f = alloca i32, align 4 in   %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] GEP offset is  constant   %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] Analyze   %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   store i32 %2, ptr %field12, align 4
[AAPointerInfo] Analyze   %f = alloca i32, align 4 in   %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] GEP offset is  constant   %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] Analyze   %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   %3 = load i32, ptr %field13, align 4
[AAPointerInfo] Analyze   %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   store i32 %add4, ptr %field13, align 4
[AAPointerInfo] Analyze   %f = alloca i32, align 4 in   %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] GEP offset is  constant   %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
[AAPointerInfo] Analyze   %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0 in   %4 = load i32, ptr %field15, align 4
Accesses by bin after update:
[0-4] : 6
     - 9 -   store i32 10, ptr %field1, align 4
       - c: i32 10
     - 5 -   %0 = load i32, ptr %field11, align 4
       - c: <unknown>
     - 9 -   store i32 %2, ptr %field12, align 4
       - c: <unknown>
     - 5 -   %3 = load i32, ptr %field13, align 4
       - c: <unknown>
     - 9 -   store i32 %add4, ptr %field13, align 4
       - c: <unknown>
     - 5 -   %4 = load i32, ptr %field15, align 4
       - c: <unknown>
[Attributor] Update unchanged [AAPointerInfo] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

[Attributor] Update: [AAIsDead] for CtxI '  %add6 = add nsw i32 %4, %5' at position {flt:add6 [add6@-1]} with state assumed-dead

[Attributor] Got 1 initial uses to check
[Attributor] Update: [AAIsDead] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %add6)' at position {cs_arg:add6 [call@1]} with state assumed-dead

[Attributor] Update changed [AAIsDead] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %add6)' at position {cs_arg:add6 [call@1]} with state assumed-live

[Attributor] Update changed [AAIsDead] for CtxI '  %add6 = add nsw i32 %4, %5' at position {flt:add6 [add6@-1]} with state assumed-live

[Attributor] Update: [AAIsDead] for CtxI '  store i32 %0, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead-store

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 %0, ptr %a, align 4 (only exact: 0)
Visit underlying object   %a = alloca i32, align 4
[AA] Object '  %a = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %1 = load i32, ptr %a, align 4 from   store i32 %0, ptr %a, align 4 intraprocedurally
[AA]   store i32 %0, ptr %a, align 4 can potentially reach   %1 = load i32, ptr %a, align 4 [Intra]
[AA] check   %2 = load i32, ptr %a, align 4 from   store i32 %0, ptr %a, align 4 intraprocedurally
[AA]   store i32 %0, ptr %a, align 4 cannot reach   %2 = load i32, ptr %a, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %2 = load i32, ptr %a, align 4 [ToFn]
[AA][Ret]   store i32 %0, ptr %a, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AAIsDead] Store has 1 potential copies.
[Attributor] Update unchanged [AAIsDead] for CtxI '  store i32 %0, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead-store

[Attributor] Update: [AAIsDead] for CtxI '  store i32 %add, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead-store

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 %add, ptr %a, align 4 (only exact: 0)
Visit underlying object   %a = alloca i32, align 4
[AA] Object '  %a = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %1 = load i32, ptr %a, align 4 from   store i32 %add, ptr %a, align 4 intraprocedurally
[AA]   store i32 %add, ptr %a, align 4 cannot reach   %1 = load i32, ptr %a, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %1 = load i32, ptr %a, align 4 [ToFn]
[AA][Ret]   store i32 %add, ptr %a, align 4 can potentially reach   ret void [Intra]
[AA] check @foo from   store i32 %add, ptr %a, align 4 is not checked backwards, abort
[AA] check   %2 = load i32, ptr %a, align 4 from   store i32 %add, ptr %a, align 4 intraprocedurally
[AA]   store i32 %add, ptr %a, align 4 can potentially reach   %2 = load i32, ptr %a, align 4 [Intra]
[AAIsDead] Store has 2 potential copies.
[Attributor] Update unchanged [AAIsDead] for CtxI '  store i32 %add, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead-store

[Attributor] Update: [AAIsDead] for CtxI '  %3 = load i32, ptr %field13, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Got 1 initial uses to check
[Attributor] Update unchanged [AAIsDead] for CtxI '  %3 = load i32, ptr %field13, align 4' at position {flt: [@-1]} with state assumed-dead



[Attributor] #Iteration: 15, Worklist size: 3
[Attributor] #Iteration: 15, Worklist+Dependent size: 15
[Attributor] Update: [AANoCapture] for CtxI '  %val.addr = alloca i32, align 4' at position {flt:val.addr [val.addr@-1]} with state assumed not-captured

[Attributor] Got 2 initial uses to check
[Attributor] Update unchanged [AANoCapture] for CtxI '  %val.addr = alloca i32, align 4' at position {flt:val.addr [val.addr@-1]} with state assumed not-captured

[Attributor] Update: [AAIsDead] for CtxI '  store i32 %val, ptr %val.addr, align 4' at position {flt: [@-1]} with state assumed-dead-store

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 %val, ptr %val.addr, align 4 (only exact: 0)
Visit underlying object   %val.addr = alloca i32, align 4
[AA] Object '  %val.addr = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %5 = load i32, ptr %val.addr, align 4 from   store i32 %val, ptr %val.addr, align 4 intraprocedurally
[AA]   store i32 %val, ptr %val.addr, align 4 can potentially reach   %5 = load i32, ptr %val.addr, align 4 [Intra]
[AAIsDead] Store has 1 potential copies.
[AAIsDead] Potential copy   %5 = load i32, ptr %val.addr, align 4 is assumed live!
[Attributor] Update changed [AAIsDead] for CtxI '  store i32 %val, ptr %val.addr, align 4' at position {flt: [@-1]} with state assumed-live

[Attributor] Update: [AAPotentialValues] for CtxI '  %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field1 [field1@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

The instruction encountered was:   %f = alloca i32, align 4!
The instruction Opcode was: 31!
Was able to create AAPointer Info object [AAPointerInfo] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

[handleAllocaInst] The first offset is the start of the Alloca.
[handleAllocaInst] Offset size cannot be reduced in Alloca.
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field1 [field1@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

[Attributor] Update: [AAPotentialValues] for CtxI '  %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field12 [field12@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

The instruction encountered was:   %f = alloca i32, align 4!
The instruction Opcode was: 31!
Was able to create AAPointer Info object [AAPointerInfo] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

[handleAllocaInst] The first offset is the start of the Alloca.
[handleAllocaInst] Offset size cannot be reduced in Alloca.
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field12 [field12@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

[Attributor] Update: [AAIsDead] for CtxI '  store i32 %2, ptr %field12, align 4' at position {flt: [@-1]} with state assumed-dead-store

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 %2, ptr %field12, align 4 (only exact: 0)
Visit underlying object   %f = alloca i32, align 4
[AA] Object '  %f = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %0 = load i32, ptr %field11, align 4 from   store i32 %2, ptr %field12, align 4 intraprocedurally
[AA]   store i32 %2, ptr %field12, align 4 cannot reach   %0 = load i32, ptr %field11, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %0 = load i32, ptr %field11, align 4 [ToFn]
[AA][Ret]   store i32 %2, ptr %field12, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AA] check   %3 = load i32, ptr %field13, align 4 from   store i32 %2, ptr %field12, align 4 intraprocedurally
[AA]   store i32 %2, ptr %field12, align 4 can potentially reach   %3 = load i32, ptr %field13, align 4 [Intra]
[AA] check   %4 = load i32, ptr %field15, align 4 from   store i32 %2, ptr %field12, align 4 intraprocedurally
[AA]   store i32 %2, ptr %field12, align 4 cannot reach   %4 = load i32, ptr %field15, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %4 = load i32, ptr %field15, align 4 [ToFn]
[AA][Ret]   store i32 %2, ptr %field12, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AAIsDead] Store has 1 potential copies.
[Attributor] Update unchanged [AAIsDead] for CtxI '  store i32 %2, ptr %field12, align 4' at position {flt: [@-1]} with state assumed-dead-store

[Attributor] Update: [AAPotentialValues] for CtxI '  %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field13 [field13@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

The instruction encountered was:   %f = alloca i32, align 4!
The instruction Opcode was: 31!
Was able to create AAPointer Info object [AAPointerInfo] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

[handleAllocaInst] The first offset is the start of the Alloca.
[handleAllocaInst] Offset size cannot be reduced in Alloca.
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field13 [field13@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

[Attributor] Update: [AAIsDead] for CtxI '  store i32 %add4, ptr %field13, align 4' at position {flt: [@-1]} with state assumed-dead-store

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 %add4, ptr %field13, align 4 (only exact: 0)
Visit underlying object   %f = alloca i32, align 4
[AA] Object '  %f = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %0 = load i32, ptr %field11, align 4 from   store i32 %add4, ptr %field13, align 4 intraprocedurally
[AA]   store i32 %add4, ptr %field13, align 4 cannot reach   %0 = load i32, ptr %field11, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %0 = load i32, ptr %field11, align 4 [ToFn]
[AA][Ret]   store i32 %add4, ptr %field13, align 4 can potentially reach   ret void [Intra]
[AA] check @foo from   store i32 %add4, ptr %field13, align 4 is not checked backwards, abort
[AA] check   %3 = load i32, ptr %field13, align 4 from   store i32 %add4, ptr %field13, align 4 intraprocedurally
[AA]   store i32 %add4, ptr %field13, align 4 cannot reach   %3 = load i32, ptr %field13, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %3 = load i32, ptr %field13, align 4 [ToFn]
[AA][Ret]   store i32 %add4, ptr %field13, align 4 can potentially reach   ret void [Intra]
[AA] check @foo from   store i32 %add4, ptr %field13, align 4 is not checked backwards, abort
[AA] check   %4 = load i32, ptr %field15, align 4 from   store i32 %add4, ptr %field13, align 4 intraprocedurally
[AA]   store i32 %add4, ptr %field13, align 4 can potentially reach   %4 = load i32, ptr %field15, align 4 [Intra]
[AAIsDead] Store has 3 potential copies.
[Attributor] Update unchanged [AAIsDead] for CtxI '  store i32 %add4, ptr %field13, align 4' at position {flt: [@-1]} with state assumed-dead-store

[Attributor] Update: [AAPotentialValues] for CtxI '  %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field15 [field15@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

The instruction encountered was:   %f = alloca i32, align 4!
The instruction Opcode was: 31!
Was able to create AAPointer Info object [AAPointerInfo] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

[handleAllocaInst] The first offset is the start of the Alloca.
[handleAllocaInst] Offset size cannot be reduced in Alloca.
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field15 [field15@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

[Attributor] Update: [AAPotentialValues] for CtxI '  %4 = load i32, ptr %field15, align 4' at position {flt: [@-1]} with state set-state(< {i32 12[3], } >)

getPotentiallyLoadedValues!
Trying to determine the potential copies of   %4 = load i32, ptr %field15, align 4 (only exact: 1)
Visit underlying object   %f = alloca i32, align 4
[AA] Object '  %f = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %4 = load i32, ptr %field15, align 4 from   store i32 10, ptr %field1, align 4 intraprocedurally
[AA]   store i32 10, ptr %field1, align 4 cannot reach   %4 = load i32, ptr %field15, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %4 = load i32, ptr %field15, align 4 [ToFn]
[AA][Ret]   store i32 10, ptr %field1, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AA] check   %4 = load i32, ptr %field15, align 4 from   store i32 %2, ptr %field12, align 4 intraprocedurally
[AA]   store i32 %2, ptr %field12, align 4 cannot reach   %4 = load i32, ptr %field15, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %4 = load i32, ptr %field15, align 4 [ToFn]
[AA][Ret]   store i32 %2, ptr %field12, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AA] check   %4 = load i32, ptr %field15, align 4 from   store i32 %add4, ptr %field13, align 4 intraprocedurally
[AA]   store i32 %add4, ptr %field13, align 4 can potentially reach   %4 = load i32, ptr %field15, align 4 [Intra]
[Attributor] Update: [AAInstanceInfo] for CtxI '  %add4 = add nsw i32 %3, 1' at position {flt:add4 [add4@-1]} with state <unique [fAa]>

[Attributor] Got 1 initial uses to check
getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 %add4, ptr %field13, align 4 (only exact: 1)
Visit underlying object   %f = alloca i32, align 4
[AA] Object '  %f = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %0 = load i32, ptr %field11, align 4 from   store i32 %add4, ptr %field13, align 4 intraprocedurally
[AA]   store i32 %add4, ptr %field13, align 4 cannot reach   %0 = load i32, ptr %field11, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %0 = load i32, ptr %field11, align 4 [ToFn]
[AA][Ret]   store i32 %add4, ptr %field13, align 4 can potentially reach   ret void [Intra]
[AA] check @foo from   store i32 %add4, ptr %field13, align 4 is not checked backwards, abort
[AA] check   %3 = load i32, ptr %field13, align 4 from   store i32 %add4, ptr %field13, align 4 intraprocedurally
[AA]   store i32 %add4, ptr %field13, align 4 cannot reach   %3 = load i32, ptr %field13, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %3 = load i32, ptr %field13, align 4 [ToFn]
[AA][Ret]   store i32 %add4, ptr %field13, align 4 can potentially reach   ret void [Intra]
[AA] check @foo from   store i32 %add4, ptr %field13, align 4 is not checked backwards, abort
[AA] check   %4 = load i32, ptr %field15, align 4 from   store i32 %add4, ptr %field13, align 4 intraprocedurally
[AA]   store i32 %add4, ptr %field13, align 4 can potentially reach   %4 = load i32, ptr %field15, align 4 [Intra]
[Attributor] Update changed [AAInstanceInfo] for CtxI '  %add4 = add nsw i32 %3, 1' at position {flt:add4 [add4@-1]} with state <unknown>

[AAPotentialValues] Not all potentially loaded values are dynamically unique:   %4 = load i32, ptr %field15, align 4
[Attributor] Update changed [AAPotentialValues] for CtxI '  %4 = load i32, ptr %field15, align 4' at position {flt: [@-1]} with state set-state(< {  %4 = load i32, ptr %field15, align 4[3], } >)

[Attributor] Update: [AAIsDead] for CtxI '  store i32 10, ptr %field1, align 4' at position {flt: [@-1]} with state assumed-dead-store

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 10, ptr %field1, align 4 (only exact: 0)
Visit underlying object   %f = alloca i32, align 4
[AA] Object '  %f = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %0 = load i32, ptr %field11, align 4 from   store i32 10, ptr %field1, align 4 intraprocedurally
[AA]   store i32 10, ptr %field1, align 4 can potentially reach   %0 = load i32, ptr %field11, align 4 [Intra]
[AA] check   %3 = load i32, ptr %field13, align 4 from   store i32 10, ptr %field1, align 4 intraprocedurally
[AA]   store i32 10, ptr %field1, align 4 cannot reach   %3 = load i32, ptr %field13, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %3 = load i32, ptr %field13, align 4 [ToFn]
[AA][Ret]   store i32 10, ptr %field1, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AA] check   %4 = load i32, ptr %field15, align 4 from   store i32 10, ptr %field1, align 4 intraprocedurally
[AA]   store i32 10, ptr %field1, align 4 cannot reach   %4 = load i32, ptr %field15, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %4 = load i32, ptr %field15, align 4 [ToFn]
[AA][Ret]   store i32 10, ptr %field1, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AAIsDead] Store has 1 potential copies.
[Attributor] Update unchanged [AAIsDead] for CtxI '  store i32 10, ptr %field1, align 4' at position {flt: [@-1]} with state assumed-dead-store

[Attributor] Update: [AAPotentialValues] for CtxI '  %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field11 [field11@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

The instruction encountered was:   %f = alloca i32, align 4!
The instruction Opcode was: 31!
Was able to create AAPointer Info object [AAPointerInfo] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

[handleAllocaInst] The first offset is the start of the Alloca.
[handleAllocaInst] Offset size cannot be reduced in Alloca.
[Attributor] Update unchanged [AAPotentialValues] for CtxI '  %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field11 [field11@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

[Attributor] Update: [AAPotentialValues] for CtxI '  %0 = load i32, ptr %field11, align 4' at position {flt: [@-1]} with state set-state(< {i32 10[3], i32 12[3], } >)

getPotentiallyLoadedValues!
Trying to determine the potential copies of   %0 = load i32, ptr %field11, align 4 (only exact: 1)
Visit underlying object   %f = alloca i32, align 4
[AA] Object '  %f = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %0 = load i32, ptr %field11, align 4 from   store i32 10, ptr %field1, align 4 intraprocedurally
[AA]   store i32 10, ptr %field1, align 4 can potentially reach   %0 = load i32, ptr %field11, align 4 [Intra]
[AA] check   %0 = load i32, ptr %field11, align 4 from   store i32 %2, ptr %field12, align 4 intraprocedurally
[AA]   store i32 %2, ptr %field12, align 4 cannot reach   %0 = load i32, ptr %field11, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %0 = load i32, ptr %field11, align 4 [ToFn]
[AA][Ret]   store i32 %2, ptr %field12, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AA] check   %0 = load i32, ptr %field11, align 4 from   store i32 %add4, ptr %field13, align 4 intraprocedurally
[AA]   store i32 %add4, ptr %field13, align 4 cannot reach   %0 = load i32, ptr %field11, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %0 = load i32, ptr %field11, align 4 [ToFn]
[AA][Ret]   store i32 %add4, ptr %field13, align 4 can potentially reach   ret void [Intra]
[AA] check @foo from   store i32 %add4, ptr %field13, align 4 is not checked backwards, abort
[AAPotentialValues] Not all potentially loaded values are dynamically unique:   %0 = load i32, ptr %field11, align 4
[Attributor] Update changed [AAPotentialValues] for CtxI '  %0 = load i32, ptr %field11, align 4' at position {flt: [@-1]} with state set-state(< {  %0 = load i32, ptr %field11, align 4[3], } >)



[Attributor] #Iteration: 16, Worklist size: 4
[Attributor] #Iteration: 16, Worklist+Dependent size: 7
[Attributor] Update: [AAIsDead] for CtxI '  %4 = load i32, ptr %field15, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Got 1 initial uses to check
[Attributor] Update changed [AAIsDead] for CtxI '  %4 = load i32, ptr %field15, align 4' at position {flt: [@-1]} with state assumed-live

[Attributor] Update: [AAPointerInfo] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state PointerInfo #1 bins

[Attributor] Got 4 initial uses to check
[AAPointerInfo] Analyze   %a = alloca i32, align 4 in   store i32 %0, ptr %a, align 4
[AAPointerInfo] Analyze   %a = alloca i32, align 4 in   %1 = load i32, ptr %a, align 4
[AAPointerInfo] Analyze   %a = alloca i32, align 4 in   store i32 %add, ptr %a, align 4
[AAPointerInfo] Analyze   %a = alloca i32, align 4 in   %2 = load i32, ptr %a, align 4
Accesses by bin after update:
[0-4] : 4
     - 9 -   store i32 %0, ptr %a, align 4
       - c: <unknown>
     - 5 -   %1 = load i32, ptr %a, align 4
       - c: <unknown>
     - 9 -   store i32 %add, ptr %a, align 4
       - c: <unknown>
     - 5 -   %2 = load i32, ptr %a, align 4
       - c: <unknown>
[Attributor] Update unchanged [AAPointerInfo] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state PointerInfo #1 bins

[Attributor] Update: [AAIsDead] for CtxI '  %0 = load i32, ptr %field11, align 4' at position {flt: [@-1]} with state assumed-dead

[Attributor] Got 1 initial uses to check
[Attributor] Update unchanged [AAIsDead] for CtxI '  %0 = load i32, ptr %field11, align 4' at position {flt: [@-1]} with state assumed-dead



[Attributor] #Iteration: 17, Worklist size: 1
[Attributor] #Iteration: 17, Worklist+Dependent size: 3
[Attributor] Update: [AAIsDead] for CtxI '  store i32 %add4, ptr %field13, align 4' at position {flt: [@-1]} with state assumed-dead-store

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 %add4, ptr %field13, align 4 (only exact: 0)
Visit underlying object   %f = alloca i32, align 4
[AA] Object '  %f = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %0 = load i32, ptr %field11, align 4 from   store i32 %add4, ptr %field13, align 4 intraprocedurally
[AA]   store i32 %add4, ptr %field13, align 4 cannot reach   %0 = load i32, ptr %field11, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %0 = load i32, ptr %field11, align 4 [ToFn]
[AA][Ret]   store i32 %add4, ptr %field13, align 4 can potentially reach   ret void [Intra]
[AA] check @foo from   store i32 %add4, ptr %field13, align 4 is not checked backwards, abort
[AA] check   %3 = load i32, ptr %field13, align 4 from   store i32 %add4, ptr %field13, align 4 intraprocedurally
[AA]   store i32 %add4, ptr %field13, align 4 cannot reach   %3 = load i32, ptr %field13, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %3 = load i32, ptr %field13, align 4 [ToFn]
[AA][Ret]   store i32 %add4, ptr %field13, align 4 can potentially reach   ret void [Intra]
[AA] check @foo from   store i32 %add4, ptr %field13, align 4 is not checked backwards, abort
[AA] check   %4 = load i32, ptr %field15, align 4 from   store i32 %add4, ptr %field13, align 4 intraprocedurally
[AA]   store i32 %add4, ptr %field13, align 4 can potentially reach   %4 = load i32, ptr %field15, align 4 [Intra]
[AAIsDead] Store has 3 potential copies.
[AAIsDead] Potential copy   %4 = load i32, ptr %field15, align 4 is assumed live!
[Attributor] Update changed [AAIsDead] for CtxI '  store i32 %add4, ptr %field13, align 4' at position {flt: [@-1]} with state assumed-live

[Attributor] Update: [AANoCapture] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state assumed not-captured

[Attributor] Got 5 initial uses to check
[Attributor] Update unchanged [AANoCapture] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state assumed not-captured



[Attributor] #Iteration: 18, Worklist size: 1
[Attributor] #Iteration: 18, Worklist+Dependent size: 3
[Attributor] Update: [AANoCapture] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state assumed not-captured

[Attributor] Got 5 initial uses to check
[Attributor] Update unchanged [AANoCapture] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state assumed not-captured

[Attributor] Update: [AAIsDead] for CtxI '  store i32 %2, ptr %field12, align 4' at position {flt: [@-1]} with state assumed-dead-store

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 %2, ptr %field12, align 4 (only exact: 0)
Visit underlying object   %f = alloca i32, align 4
[AA] Object '  %f = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %0 = load i32, ptr %field11, align 4 from   store i32 %2, ptr %field12, align 4 intraprocedurally
[AA]   store i32 %2, ptr %field12, align 4 cannot reach   %0 = load i32, ptr %field11, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %0 = load i32, ptr %field11, align 4 [ToFn]
[AA][Ret]   store i32 %2, ptr %field12, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AA] check   %3 = load i32, ptr %field13, align 4 from   store i32 %2, ptr %field12, align 4 intraprocedurally
[AA]   store i32 %2, ptr %field12, align 4 can potentially reach   %3 = load i32, ptr %field13, align 4 [Intra]
[AA] check   %4 = load i32, ptr %field15, align 4 from   store i32 %2, ptr %field12, align 4 intraprocedurally
[AA]   store i32 %2, ptr %field12, align 4 cannot reach   %4 = load i32, ptr %field15, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %4 = load i32, ptr %field15, align 4 [ToFn]
[AA][Ret]   store i32 %2, ptr %field12, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AAIsDead] Store has 1 potential copies.
[AAIsDead] Potential copy   %3 = load i32, ptr %field13, align 4 is assumed live!
[Attributor] Update changed [AAIsDead] for CtxI '  store i32 %2, ptr %field12, align 4' at position {flt: [@-1]} with state assumed-live



[Attributor] #Iteration: 19, Worklist size: 1
[Attributor] #Iteration: 19, Worklist+Dependent size: 3
[Attributor] Update: [AAIsDead] for CtxI '  store i32 %add, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead-store

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 %add, ptr %a, align 4 (only exact: 0)
Visit underlying object   %a = alloca i32, align 4
[AA] Object '  %a = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %1 = load i32, ptr %a, align 4 from   store i32 %add, ptr %a, align 4 intraprocedurally
[AA]   store i32 %add, ptr %a, align 4 cannot reach   %1 = load i32, ptr %a, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %1 = load i32, ptr %a, align 4 [ToFn]
[AA][Ret]   store i32 %add, ptr %a, align 4 can potentially reach   ret void [Intra]
[AA] check @foo from   store i32 %add, ptr %a, align 4 is not checked backwards, abort
[AA] check   %2 = load i32, ptr %a, align 4 from   store i32 %add, ptr %a, align 4 intraprocedurally
[AA]   store i32 %add, ptr %a, align 4 can potentially reach   %2 = load i32, ptr %a, align 4 [Intra]
[AAIsDead] Store has 2 potential copies.
[AAIsDead] Potential copy   %2 = load i32, ptr %a, align 4 is assumed live!
[Attributor] Update changed [AAIsDead] for CtxI '  store i32 %add, ptr %a, align 4' at position {flt: [@-1]} with state assumed-live

[Attributor] Update: [AANoCapture] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state assumed not-captured

[Attributor] Got 4 initial uses to check
[Attributor] Update unchanged [AANoCapture] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state assumed not-captured



[Attributor] #Iteration: 20, Worklist size: 1
[Attributor] #Iteration: 20, Worklist+Dependent size: 3
[Attributor] Update: [AAIsDead] for CtxI '  store i32 %0, ptr %a, align 4' at position {flt: [@-1]} with state assumed-dead-store

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 %0, ptr %a, align 4 (only exact: 0)
Visit underlying object   %a = alloca i32, align 4
[AA] Object '  %a = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %1 = load i32, ptr %a, align 4 from   store i32 %0, ptr %a, align 4 intraprocedurally
[AA]   store i32 %0, ptr %a, align 4 can potentially reach   %1 = load i32, ptr %a, align 4 [Intra]
[AA] check   %2 = load i32, ptr %a, align 4 from   store i32 %0, ptr %a, align 4 intraprocedurally
[AA]   store i32 %0, ptr %a, align 4 cannot reach   %2 = load i32, ptr %a, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %2 = load i32, ptr %a, align 4 [ToFn]
[AA][Ret]   store i32 %0, ptr %a, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AAIsDead] Store has 1 potential copies.
[AAIsDead] Potential copy   %1 = load i32, ptr %a, align 4 is assumed live!
[Attributor] Update changed [AAIsDead] for CtxI '  store i32 %0, ptr %a, align 4' at position {flt: [@-1]} with state assumed-live

[Attributor] Update: [AANoCapture] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state assumed not-captured

[Attributor] Got 4 initial uses to check
[Attributor] Update unchanged [AANoCapture] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state assumed not-captured



[Attributor] #Iteration: 21, Worklist size: 1
[Attributor] #Iteration: 21, Worklist+Dependent size: 4
[Attributor] Update: [AAIsDead] for CtxI '  store i32 10, ptr %field1, align 4' at position {flt: [@-1]} with state assumed-dead-store

getPotentialCopiesOfStoredValue!
Trying to determine the potential copies of   store i32 10, ptr %field1, align 4 (only exact: 0)
Visit underlying object   %f = alloca i32, align 4
[AA] Object '  %f = alloca i32, align 4' is  thread local; non-captured stack object.
[AA] check   %0 = load i32, ptr %field11, align 4 from   store i32 10, ptr %field1, align 4 intraprocedurally
[AA]   store i32 10, ptr %field1, align 4 can potentially reach   %0 = load i32, ptr %field11, align 4 [Intra]
[AA] check   %3 = load i32, ptr %field13, align 4 from   store i32 10, ptr %field1, align 4 intraprocedurally
[AA]   store i32 10, ptr %field1, align 4 cannot reach   %3 = load i32, ptr %field13, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %3 = load i32, ptr %field13, align 4 [ToFn]
[AA][Ret]   store i32 10, ptr %field1, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AA] check   %4 = load i32, ptr %field15, align 4 from   store i32 10, ptr %field1, align 4 intraprocedurally
[AA]   store i32 10, ptr %field1, align 4 cannot reach   %4 = load i32, ptr %field15, align 4 [Intra]
[AA] Entry   %val.addr = alloca i32, align 4 of @foo cannot reach @  %4 = load i32, ptr %field15, align 4 [ToFn]
[AA][Ret]   store i32 10, ptr %field1, align 4 cannot reach   ret void [Intra]
[AA] No return is reachable, done
[AAIsDead] Store has 1 potential copies.
[AAIsDead] Potential copy   %0 = load i32, ptr %field11, align 4 is assumed live!
[Attributor] Update changed [AAIsDead] for CtxI '  store i32 10, ptr %field1, align 4' at position {flt: [@-1]} with state assumed-live

[Attributor] Update: [AANoCapture] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state assumed not-captured

[Attributor] Got 5 initial uses to check
[Attributor] Update unchanged [AANoCapture] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state assumed not-captured



[Attributor] #Iteration: 22, Worklist size: 1
[Attributor] #Iteration: 22, Worklist+Dependent size: 1

[Attributor] Fixpoint iteration done after: 22/32 iterations
[Attributor] Manifest unchanged : [AAUndefinedBehavior] for CtxI '  %val.addr = alloca i32, align 4' at position {fn:foo [foo@-1]} with state undefined-behavior

[Attributor] Manifest changed : [AAPotentialValues] for CtxI '  %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field11 [field11@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

[Attributor] Manifest unchanged : [AAPointerInfo] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state PointerInfo #1 bins

[Attributor] Manifest unchanged : [AAPotentialValues] for CtxI <<null inst>> at position {flt: [@-1]} with state set-state(< {i32 10[3], } >)

[Attributor] Manifest unchanged : [AAPotentialValues] for CtxI '  %2 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state set-state(< {  %2 = load i32, ptr %a, align 4[3], } >)

[Attributor] Manifest unchanged : [AAUnderlyingObjects] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state UnderlyingObjects inter #1 objs, intra #1 objs

[Attributor] Manifest unchanged : [AAPotentialValues] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state set-state(< {  %a = alloca i32, align 4[3], } >)

[Attributor] Manifest unchanged : [AAPointerInfo] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state PointerInfo #1 bins

[Attributor] Manifest unchanged : [AAPotentialValues] for CtxI '  %0 = load i32, ptr %field11, align 4' at position {flt: [@-1]} with state set-state(< {  %0 = load i32, ptr %field11, align 4[3], } >)

[Attributor] Manifest unchanged : [AAUnderlyingObjects] for CtxI '  %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field11 [field11@-1]} with state UnderlyingObjects inter #1 objs, intra #1 objs

[Attributor] Manifest unchanged : [AAPotentialValues] for CtxI '  %add = add nsw i32 %1, 1' at position {flt:add [add@-1]} with state set-state(< {  %add = add nsw i32 %1, 1[3], } >)

[Attributor] Manifest unchanged : [AAPotentialValues] for CtxI '  %1 = load i32, ptr %a, align 4' at position {flt: [@-1]} with state set-state(< {  %1 = load i32, ptr %a, align 4[3], } >)

[Attributor] Manifest unchanged : [AAPotentialValues] for CtxI <<null inst>> at position {flt: [@-1]} with state set-state(< {i32 1[3], } >)

[Attributor] Manifest unchanged : [AAUnderlyingObjects] for CtxI '  %val.addr = alloca i32, align 4' at position {flt:val.addr [val.addr@-1]} with state UnderlyingObjects inter #1 objs, intra #1 objs

[Attributor] Manifest unchanged : [AAPotentialValues] for CtxI '  %val.addr = alloca i32, align 4' at position {flt:val.addr [val.addr@-1]} with state set-state(< {  %val.addr = alloca i32, align 4[3], } >)

[Attributor] Manifest unchanged : [AAPointerInfo] for CtxI '  %val.addr = alloca i32, align 4' at position {flt:val.addr [val.addr@-1]} with state PointerInfo #1 bins

[Attributor] Manifest unchanged : [AAPotentialValues] for CtxI '  %val.addr = alloca i32, align 4' at position {arg:val [val@0]} with state set-state(< {i32 %val[3], } >)

[Attributor] Manifest unchanged : [AANoCapture] for CtxI '  %val.addr = alloca i32, align 4' at position {flt:val.addr [val.addr@-1]} with state known not-captured

[Attributor] Manifest unchanged : [AAUnderlyingObjects] for CtxI '  %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field1 [field1@-1]} with state UnderlyingObjects inter #1 objs, intra #1 objs

[Attributor] Manifest changed : [AAPotentialValues] for CtxI '  %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field1 [field1@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

[Attributor] Manifest unchanged : [AAPotentialValues] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

[Attributor] Manifest unchanged : [AANoCapture] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state known not-captured

[Attributor] Manifest unchanged : [AANoCapture] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state known not-captured

[Attributor] Manifest unchanged : [AAInterFnReachability] for CtxI '  %val.addr = alloca i32, align 4' at position {fn:foo [foo@-1]} with state #queries(2)

[Attributor] Manifest unchanged : [AAIntraFnReachability] for CtxI '  %val.addr = alloca i32, align 4' at position {fn:foo [foo@-1]} with state #queries(44)

[Attributor] Manifest unchanged : [AACallEdges] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %add6)' at position {cs:call [call@-1]} with state CallEdges[0,1]

[Attributor] Manifest unchanged : [AAPotentialValues] for CtxI <<null inst>> at position {flt:printf [printf@-1]} with state set-state(< {@printf[3], } >)

[Attributor] Manifest unchanged : [AAUnderlyingObjects] for CtxI '  %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field12 [field12@-1]} with state UnderlyingObjects inter #1 objs, intra #1 objs

[Attributor] Manifest changed : [AAPotentialValues] for CtxI '  %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field12 [field12@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

[Attributor] Manifest unchanged : [AAPotentialValues] for CtxI '  %3 = load i32, ptr %field13, align 4' at position {flt: [@-1]} with state set-state(< {  %3 = load i32, ptr %field13, align 4[3], } >)

[Attributor] Manifest unchanged : [AAUnderlyingObjects] for CtxI '  %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field13 [field13@-1]} with state UnderlyingObjects inter #1 objs, intra #1 objs

[Attributor] Manifest changed : [AAPotentialValues] for CtxI '  %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field13 [field13@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

[Attributor] Manifest unchanged : [AAPotentialValues] for CtxI '  %4 = load i32, ptr %field15, align 4' at position {flt: [@-1]} with state set-state(< {  %4 = load i32, ptr %field15, align 4[3], } >)

[Attributor] Manifest unchanged : [AAUnderlyingObjects] for CtxI '  %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field15 [field15@-1]} with state UnderlyingObjects inter #1 objs, intra #1 objs

[Attributor] Manifest changed : [AAPotentialValues] for CtxI '  %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field15 [field15@-1]} with state set-state(< {  %f = alloca i32, align 4[3], } >)

[Attributor] Manifest changed : [AAPotentialValues] for CtxI '  %5 = load i32, ptr %val.addr, align 4' at position {flt: [@-1]} with state set-state(< {i32 %val[3], } >)

[Attributor] Manifest unchanged : [AAInstanceInfo] for CtxI '  %val.addr = alloca i32, align 4' at position {arg:val [val@0]} with state <unique [fAa]>

[Attributor] Manifest unchanged : [AAPotentialValues] for CtxI '  %add6 = add nsw i32 %4, %5' at position {flt:add6 [add6@-1]} with state set-state(< {  %add6 = add nsw i32 %4, %5[3], } >)

[Attributor] Manifest unchanged : [AAPotentialValues] for CtxI '  %add4 = add nsw i32 %3, 1' at position {flt:add4 [add4@-1]} with state set-state(< {  %add4 = add nsw i32 %3, 1[3], } >)

[Attributor] Manifest unchanged : [AANoUndef] for CtxI '  %call = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %add6)' at position {cs_arg:.str [call@0]} with state noundef

[Attributor] Manifest unchanged : [AAPotentialValues] for CtxI <<null inst>> at position {flt:.str [.str@-1]} with state set-state(< {@.str = private unnamed_addr constant [15 x i8] c"Field 1 is %d\0A\00", align 1[3], } >)

[Attributor] Manifest unchanged : [AAHeapToStack] for CtxI '  %val.addr = alloca i32, align 4' at position {fn:foo [foo@-1]} with state [H2S] Mallocs Good/Bad: 0/0

[Attributor] Manifest unchanged : [AAAlign] for CtxI '  %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field11 [field11@-1]} with state align<4-4>

[Attributor] Manifest unchanged : [AAAlign] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state align<4-4>

[Attributor] Manifest unchanged : [AAAlign] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state align<4-4>

[Attributor] Manifest unchanged : [AAAlign] for CtxI '  %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field13 [field13@-1]} with state align<4-4>

[Attributor] Manifest unchanged : [AAAlign] for CtxI '  %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field15 [field15@-1]} with state align<4-4>

[Attributor] Manifest unchanged : [AAAlign] for CtxI '  %val.addr = alloca i32, align 4' at position {flt:val.addr [val.addr@-1]} with state align<4-4>

[Attributor] Manifest unchanged : [AAAlign] for CtxI '  %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field1 [field1@-1]} with state align<4-4>

[Attributor] Manifest unchanged : [AAAlign] for CtxI '  %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0' at position {flt:field12 [field12@-1]} with state align<4-4>

[Attributor] Manifest unchanged : [AAUndefinedBehavior] for CtxI '  call void @foo(i32 noundef 10)' at position {fn:main [main@-1]} with state undefined-behavior

[Attributor] Manifest unchanged : [AANoUnwind] for CtxI '  call void @foo(i32 noundef 10)' at position {cs: [@-1]} with state nounwind

[Attributor] Manifest unchanged : [AANoUndef] for CtxI '  call void @foo(i32 noundef 10)' at position {cs_arg: [@0]} with state noundef

[Attributor] Manifest changed : [AANoUndef] for CtxI '  call void @foo(i32 noundef 10)' at position {fn_ret:main [main@-1]} with state noundef

[Attributor] Manifest unchanged : [AAReturnedValues] for CtxI '  call void @foo(i32 noundef 10)' at position {fn:main [main@-1]} with state returns(#1)

[Attributor] Manifest unchanged : [AAPotentialValues] for CtxI <<null inst>> at position {flt: [@-1]} with state set-state(< {i32 0[3], } >)

[Attributor] Manifest unchanged : [AANoUndef] for CtxI <<null inst>> at position {flt: [@-1]} with state noundef

[Attributor] Manifest unchanged : [AAHeapToStack] for CtxI '  call void @foo(i32 noundef 10)' at position {fn:main [main@-1]} with state [H2S] Mallocs Good/Bad: 0/0

[Attributor] Manifest unchanged : [AAInterFnReachability] for CtxI '  call void @foo(i32 noundef 10)' at position {fn:main [main@-1]} with state #queries(1)

[Attributor] Manifest unchanged : [AAIntraFnReachability] for CtxI '  call void @foo(i32 noundef 10)' at position {fn:main [main@-1]} with state #queries(0)

[Attributor] Manifest unchanged : [AACallEdges] for CtxI '  call void @foo(i32 noundef 10)' at position {cs: [@-1]} with state CallEdges[0,1]

[Attributor] Manifest unchanged : [AAPotentialValues] for CtxI '  %val.addr = alloca i32, align 4' at position {flt:foo [foo@-1]} with state set-state(< {@foo[3], } >)

[Attributor] Manifest unchanged : [AAPotentialValues] for CtxI '  call void @foo(i32 noundef 10)' at position {fn_ret:main [main@-1]} with state set-state(< {i32 0[3], } >)

[Attributor] Manifest unchanged : [AAPotentialValues] for CtxI '  call void @foo(i32 noundef 10)' at position {cs_arg: [@0]} with state set-state(< {i32 10[3], } >)

[Attributor] Manifest unchanged : [AAInstanceInfo] for CtxI <<null inst>> at position {flt: [@-1]} with state <unique [fAa]>

[Attributor] Manifest unchanged : [AAPotentialValues] for CtxI <<null inst>> at position {flt: [@-1]} with state set-state(< {i32 11[3], } >)

[Attributor] Manifest unchanged : [AAInstanceInfo] for CtxI <<null inst>> at position {flt: [@-1]} with state <unique [fAa]>

[Attributor] Manifest unchanged : [AAPotentialValues] for CtxI <<null inst>> at position {flt: [@-1]} with state set-state(< {i32 12[3], } >)

[Attributor] Manifest unchanged : [AAInstanceInfo] for CtxI '  %a = alloca i32, align 4' at position {flt:a [a@-1]} with state <unique [fAa]>

[Attributor] Manifest unchanged : [AAInstanceInfo] for CtxI '  %f = alloca i32, align 4' at position {flt:f [f@-1]} with state <unique [fAa]>

[Attributor] Manifest unchanged : [AAInstanceInfo] for CtxI <<null inst>> at position {flt: [@-1]} with state <unique [fAa]>


[Attributor] Manifested 7 arguments while 71 were in a valid fixpoint state

[Attributor] Delete/replace at least 0 functions and 0 blocks and 0 instructions and 6 values and 0 uses. To insert 0 unreachables.
Preserve manifest added 0 blocks
Use   %f = alloca i32, align 4 in   %0 = load i32, ptr %field11, align 4 instead of   %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
Use   %f = alloca i32, align 4 in   store i32 10, ptr %field1, align 4 instead of   %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
Use   %f = alloca i32, align 4 in   store i32 %2, ptr %field12, align 4 instead of   %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
Use   %f = alloca i32, align 4 in   store i32 %add4, ptr %field13, align 4 instead of   %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
Use   %f = alloca i32, align 4 in   %3 = load i32, ptr %field13, align 4 instead of   %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
Use   %f = alloca i32, align 4 in   %4 = load i32, ptr %field15, align 4 instead of   %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
Use i32 %val in   %add6 = add nsw i32 %4, %5 instead of   %5 = load i32, ptr %val.addr, align 4
[Attributor] DeadInsts size: 6
  -   %field11 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
  -   %field1 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
  -   %field12 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
  -   %field13 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
  -   %field15 = getelementptr inbounds %struct.Foo, ptr %f, i32 0, i32 0
  -   %5 = load i32, ptr %val.addr, align 4
[Attributor] Deleted 0 functions after manifest.
[Attributor] Done with 3 functions, result: changed.
